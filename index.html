<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>J0hnnny&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="J0hnnny's blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="J0hnnny's blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="J0hnnny's blog">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="J0hnnny&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://ww3.sinaimg.cn/large/5dd70eb5jw8esyss3o3wxg20c80c80u9.gif" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">J0hnnny</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/j0hdev" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/jcack" title="weibo">weibo</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/学习笔记-汇编语言/" style="font-size: 10px;">学习笔记 汇编语言</a> <a href="/tags/算法/" style="font-size: 20px;">算法</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">在读学生，追求完美的开发水平，对美的事物充满好奇和兴趣。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">J0hnnny</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://ww3.sinaimg.cn/large/5dd70eb5jw8esyss3o3wxg20c80c80u9.gif" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">J0hnnny</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/j0hdev" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/jcack" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-每日一算法（第五天）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/14/每日一算法（第五天）/" class="article-date">
  	<time datetime="2016-07-14T10:22:26.000Z" itemprop="datePublished">2016-07-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/14/每日一算法（第五天）/">每日一算法（第五天）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种先进后出的数据结构，很简单就不细说了。今天是用栈来实现判断是否是回文串的算法。思路是这样的，把字符串的一半压栈，然后出栈一个字符和另一半的第一个字符对比，如果一样，就把栈指针减一，否则跳出循环。如果最终栈指针为0，则它是回文串，否则不是。</p>
<p>Swift 版实现：</p>
<p>我自己写了一个精简修改版的栈，这里为了让栈指针在比对后减一，所以在出栈的方法中没有让它减一。</p>
<p>首先是栈的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct Stack &lt;T&gt; &#123;</span><br><span class="line">    var data = [T]()</span><br><span class="line">    var top = 0</span><br><span class="line">    mutating func push(value value: T)&#123;</span><br><span class="line">        data.append(value)</span><br><span class="line">        top += 1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func pop() -&gt; T &#123;</span><br><span class="line">        return data.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现了一个支持泛型的栈，Just for fun ^_^</p>
<p>Swift 的 <code>String</code> 类型有一个坑爹的地方，就是不能通过下标来获取某一个字符，还有，它没有 <code>length</code> 属性，所以我先写了一个扩展来让它具备这样的功能，方便一会写算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">extension String &#123;</span><br><span class="line">    subscript(range: Range&lt;Int&gt;) -&gt; String &#123;</span><br><span class="line">        get&#123;</span><br><span class="line">            let startIndex = self.startIndex.advancedBy(range.startIndex)</span><br><span class="line">            let endIndex = self.startIndex.advancedBy(range.endIndex)</span><br><span class="line">            return self[startIndex..&lt;endIndex]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    subscript(index: Int) -&gt; String &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            let startIndex = self.startIndex.advancedBy(index)</span><br><span class="line">            let endIndex = self.startIndex.advancedBy(index + 1)</span><br><span class="line">            return self[startIndex ..&lt; endIndex]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var length: Int &#123; return (self as NSString).length &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在 <code>String</code> 已经可以实现通过下标的方式来取一个字符串，和通过一段范围来截取一段字符串了。</p>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;abcdef&quot;</span><br><span class="line">str[1] // b</span><br><span class="line">str[1..&lt;3] //bc</span><br><span class="line">str[1...3] //bcd</span><br></pre></td></tr></table></figure>
<p>算法很简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func isPalindromic() &#123;</span><br><span class="line">    let str = &quot;ahaha&quot;</span><br><span class="line">    let mid = str.length / 2 - 1</span><br><span class="line">    var stack = Stack&lt;String&gt;()</span><br><span class="line">    var next = 0</span><br><span class="line">    </span><br><span class="line">    for index in 0...mid &#123;</span><br><span class="line">        stack.push(value: str[index])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (str.length % 2 == 0) &#123;</span><br><span class="line">        next = mid + 1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        next = mid + 2</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for index in next...str.length - 1 &#123;</span><br><span class="line">        if (stack.pop() != str[index]) &#123;</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">        stack.top -= 1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (stack.top == 0) &#123;</span><br><span class="line">        print(&quot;是回文串&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        print(&quot;不是回文串&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-每日一算法（第四天）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/13/每日一算法（第四天）/" class="article-date">
  	<time datetime="2016-07-13T09:39:02.000Z" itemprop="datePublished">2016-07-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/13/每日一算法（第四天）/">每日一算法（第四天）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>今天不纯是算法，还有数据结构。</p>
<p>如果别人问你要一个QQ号，你不想直接给他，你告诉他一个加密的序列（比如: <code>6, 3, 1, 7, 5, 8, 9, 2, 0</code>），然后告诉他将第<code>1</code>个元素删除，把第<code>2</code>个元素移动到序列的末尾，然后把第<code>3</code>个元素删除，把第<code>4</code>个元素移动到序列的末尾，直到遇到最后一个元素，把它也删除，然后把这些删除的元素连在一起就是你要的QQ号。</p>
<p>这样的需求你应该怎么做？按照死办法，就是初始化一个数组，初始化的元素就是上面的那些元素，然后开始删除第一个元素，怎么删？把第一个元素之后的所有元素的下标统统往前减一，那么这么做就非常费时了，如果用队列来做就会快许多。</p>
<p>队列的实现就需要一个<code>head</code>、和一个<code>tail</code>两个变量来表示队列的首元素和末元素的下标，当需要删除一个元素时，只需要把<code>head++</code>即可，对于 <code>tail</code> 元素，要让它等于<code>末元素下标+1</code>，因为我们不想到最后让 <code>head == tail</code> 时队列中还剩下一个元素，我们判断队列为空的时才希望让<code>head == tail</code>。如果需要在末尾追加一个元素就只要让数组<code>tail</code>下标的那块区域添加上要追加的那个元素，然后把<code>tail++</code>，这样不管是删除还是追加的时间复杂度均为O(1)，效率非常高，但是浪费了一些空间，这就叫用空间换时间，上帝是不会让你十全十美的。</p>
<p>Swift 版实现:</p>
<p>首先创建一个结构体来表示一个队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Queue &#123;</span><br><span class="line">    var data: [Int]</span><br><span class="line">    var head: Int</span><br><span class="line">    var tail: Int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是具体的算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func jailbrokenQQ() &#123;</span><br><span class="line">	//为了保证有足够的空间来换来换去这些元素，就预留了100个位置</span><br><span class="line">    var queue = Queue(data: [Int](count: 100, repeatedValue: 0), head: 0, tail: 0)</span><br><span class="line">    var data = [6, 3, 1, 7, 5, 8, 9, 2, 0]</span><br><span class="line">    </span><br><span class="line">    //把加密的QQ号码丢进队列里</span><br><span class="line">    for index in 0...data.count - 1 &#123;</span><br><span class="line">        queue.data[index] = data[index]</span><br><span class="line">        queue.tail += 1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //根据解密的逻辑开始解密</span><br><span class="line">    while queue.head &lt; queue.tail &#123;</span><br><span class="line">        print(queue.data[queue.head])</span><br><span class="line">        queue.head += 1</span><br><span class="line">        queue.data[queue.tail] = queue.data[queue.head]</span><br><span class="line">        queue.tail += 1</span><br><span class="line">        queue.head += 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用合适的数据结构来实现同一个算法，会让效率大大增加。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-每日一算法（第三天）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/12/每日一算法（第三天）/" class="article-date">
  	<time datetime="2016-07-12T08:40:41.000Z" itemprop="datePublished">2016-07-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/12/每日一算法（第三天）/">每日一算法（第三天）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>这是一个比昨天的冒泡排序快一点的排序算法，它的思路是这样的：在一个无序的序列中随便寻找一个基准值，一般选择序列的第一个元素，根据这个基准值，把基准值左边比基准值大的统统移到它的右边，把它的右边比它小的统统移到左边，那么这样一来，基准值的左边都是比它小的，右边呢都是比它大的。这样子的一轮就称他为基准值归位（因为一轮完毕以后基准值肯定是在中间），一轮完毕后基准值就把这一串序列分为了左右两串子序列，对于左右两串子序列，我们还可以继续找基准值，继续让大的移右边，小的移左边，所有基准归位完毕后，这串序列就排序完成了。</p>
<p>至于怎么把小于基准的值移左边，大于基准的值移右边，我们可以采用交换的方法，使用两个指针分别指向序列中第一个元素和最后一个元素，然后让两个指针相向移动，<em>但是必须让尾指针先移动，因为基准是第一个元素</em>，尾指针（指向最后一个元素）遇到比基准<code>小</code>的元素就暂时停止移动，等到头指针遇到了一个比基准<code>大</code>的元素，也暂时停止移动，让两个指针指向的元素互换，然后继续移动，继续和上面说明的操作步骤一样进行，当头尾指针相遇时，就说明一轮已经结束了（第一个序列的基准已经归位），然后继续递归做后续序列基准的归位。</p>
<p>Swift 实现（这个算法比较复杂，所以注释特别多）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">var array = [6,1,2,7,9,3,4,5,10,8]</span><br><span class="line"></span><br><span class="line">func quickSort(left left: Int, right: Int)&#123;</span><br><span class="line">    </span><br><span class="line">    //如果 left 大于 right 说明排序已经完成，递归结束</span><br><span class="line">    if (left &gt; right) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var i = left //指向第一个元素</span><br><span class="line">    var j = right //指向第二个元素</span><br><span class="line">    let temp = array[left] //存放基准数</span><br><span class="line">    var t = 0 //交换时临时存放</span><br><span class="line">    </span><br><span class="line">    //i 不等于 j 说明这两个指针还没有碰头</span><br><span class="line">    while i != j &#123;</span><br><span class="line">        </span><br><span class="line">        //如果基准数右边的数大于基准数，就说明符合要求，不需要交换，所以指针继续往前面移动，i 如果大于 j 说明已经碰头了</span><br><span class="line">        while array[j] &gt;= temp &amp;&amp; i &lt; j  &#123;</span><br><span class="line">            j -= 1</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //如果基准数左边的数小于基准数，就说明符合要求，不需要交换。所以指针继续往后面移动，.....</span><br><span class="line">        while array[i] &lt;= temp &amp;&amp; i &lt; j &#123;</span><br><span class="line">            i += 1</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //前面的搜索都找到了不符合要求（即基准右边小于基准，基准左边大于基准），并且 i 和 j 没有碰头，就开始交换 i 和 j 所指向的两个元素</span><br><span class="line">        if (i &lt; j) &#123;</span><br><span class="line">            t = array[i]</span><br><span class="line">            array[i] = array[j]</span><br><span class="line">            array[j] = t</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //出了大的 while 循环，肯定就代表 i == j，意味着碰头了，那么一轮匹配就结束了</span><br><span class="line">    array[left] = array[i]</span><br><span class="line">    array[i] = temp</span><br><span class="line">    </span><br><span class="line">    //继续把上一个基准分割的两个序列和刚才一样操作，所以就要用递归来搞定</span><br><span class="line">    </span><br><span class="line">    //对于左边的子序列，头指针肯定还是left，也就是第0个元素的位置，尾指针则是刚才基准数那个位置的前面一个位置</span><br><span class="line">    quickSort(left: left, right: i - 1)</span><br><span class="line">    </span><br><span class="line">    //对于右边的子序列，头指针是刚才基准数那个位置的后面一个位置，而尾指针肯定还是right，也就是最后一个元素的位置</span><br><span class="line">    quickSort(left: i + 1, right: right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">quickSort(left: 0, right: array.count - 1)</span><br><span class="line"></span><br><span class="line">print(array)</span><br></pre></td></tr></table></figure>
<p>快速排序的平均时间复杂度为 O(NlogN)，在最差的情况下和冒泡一样达到 O(N^2)，但还是比冒泡好多了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-每日一算法（第二天）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/11/每日一算法（第二天）/" class="article-date">
  	<time datetime="2016-07-11T09:43:12.000Z" itemprop="datePublished">2016-07-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/11/每日一算法（第二天）/">每日一算法（第二天）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="冒泡算法"><a href="#冒泡算法" class="headerlink" title="冒泡算法"></a>冒泡算法</h2><p>冒泡算法的思路是这样的，如果有 n 个元素，就循环 n-1 遍，每一遍都会比较相邻的两个元素的小大（根据从小到大或从大到小的需求来比较大小）可以根据需求，大的和小的（或小的和大的）调换位置，也是非常简单的算法。</p>
<p>Swift 版实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func bubble()&#123;</span><br><span class="line">    </span><br><span class="line">    var array = [10,3,1,4,4,0,2]</span><br><span class="line">    </span><br><span class="line">    for _ in 1..&lt;array.count &#123;</span><br><span class="line">        for index in 0..&lt;array.count - 1 &#123;</span><br><span class="line">            if(array[index] &gt; array[index + 1]) &#123;</span><br><span class="line">                let t = array[index]</span><br><span class="line">                array[index] = array[index + 1]</span><br><span class="line">                array[index + 1] = t</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    print(array)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个算法的缺点是太慢，时间复杂度为 O(n^2)</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-每日一算法（第一天）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/10/每日一算法（第一天）/" class="article-date">
  	<time datetime="2016-07-10T10:33:04.000Z" itemprop="datePublished">2016-07-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/10/每日一算法（第一天）/">每日一算法（第一天）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>开始放暑假了，我的每日计划之一就是每天学习一个算法，我这次用的书是比较通俗易懂的《啊哈！算法》这里一共有30多个算法，不出意外，我一个多月就能看完，我会把每次看完一个算法的心得和算法的 Swift 实现写在每一次的博客里。</p>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>这是一个非常简单的排序算法，思路是这样的，比如你有一堆的数需要排序，那么首先必须确认这些数的范围，比如[0,10]，那么你就需要11个变量来保存这些数出现的次数，为什么需要11个变量呢？因为在上述的范围中最大值只能是10，最小值只能是0，那你正好就需要11个变量（一个长度为11的数组）下标依次从<code>a[0] -&gt; a[10]</code>。比方这样一堆数：5 8 3 2 1 1 5 ，在这样一堆数中：5 和 1 出现了两次，其余的数各出现一次。刚才声明的那一个长度为11的数组可以想象成是一个个桶，在这些桶里保存的都是这个桶下标那个数所出现的次数，比如 5 出现了两次，那么在元素<code>a[5] = 2</code>，1也出现了两次 <code>a[1] = 2</code>，8 出现了一次，那么 <code>a[8] = 1</code>，最后把每一个元素不为0的下标输出，即为排序过后的顺序。</p>
<p>Swift 版实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func barrel()&#123;</span><br><span class="line">    </span><br><span class="line">    var input = [10,5,20,3,1,5,2,8] //乱序的数</span><br><span class="line">    var t = 0;</span><br><span class="line">    var a = [Int]() //桶</span><br><span class="line">	</span><br><span class="line">	//桶里每一个元素置0</span><br><span class="line">    for _ in 0...21 &#123;</span><br><span class="line">        a.append(0)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //遍历乱序的元素，元素出现一次就丢进桶里并计数</span><br><span class="line">    for i in 0...input.count - 1 &#123;</span><br><span class="line">        t = input[i]</span><br><span class="line">        a[t] += 1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //输出</span><br><span class="line">    for index in 0...a.count - 1 &#123;</span><br><span class="line">        let count = a[index]</span><br><span class="line">        if count == 0 &#123;continue&#125;</span><br><span class="line">        for _ in 1...count &#123;</span><br><span class="line">            print(index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个算法的缺点在于，如果乱序的元素范围够大，那么你就需要更多的变量（桶）来存放元素出现的顺序，这对空间非常浪费，而且如果要排序的元素是小数，那就更头疼了，但如果范围不大，这个算法的时间复杂度非常快  <code>O(M+N)</code>。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-汇编语言学习笔记-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/28/汇编语言学习笔记-1/" class="article-date">
  	<time datetime="2016-06-28T03:37:35.000Z" itemprop="datePublished">2016-06-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/28/汇编语言学习笔记-1/">汇编语言学习笔记(1)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="关于书"><a href="#关于书" class="headerlink" title="关于书"></a>关于书</h1><p>为了深入学习计算机底层，开始学习汇编。这是第一篇学习笔记，书是 王爽的《汇编语言》，这本书虽然是国人写的，但是不是一本一板一眼的书，对于很多名词和概念他不会一口气讲完，而是会在每一个知识点中慢慢渗透的讲解，书后面还有习题帮助你理解，我个人认为非常好，非常适合自学五星好评。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>所有的16进制如果一眼能看出来是16进制的，比如 005c 那就不加 H， 如果看不出的 8226 那就加一个H 8226h 或者 8226H，大小写看心情。</p>
<p>以下的文章只是学习笔记，非教程，是以我能看懂温习为主。</p>
<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>一个典型的CPU是由运算器、控制器、寄存器等组成，这些器件靠内部总线来传递数据。</p>
<p>不同的CPU寄存器数量、结构不同，8086有14个寄存器，AX BX CX DX SI DI SP BP IP CS SS DS ES PSW。</p>
<p>其中 AX BX CX DX 是通用寄存器，用来存放一般性的数据。</p>
<p>为了兼容上一代CPU（8位的寄存器，而8086是16位的）上述四个通用寄存器可以分为两个独立使用的8位寄存器来用</p>
<ul>
<li>AX -&gt; AH AL</li>
<li>BX -&gt; BH BL</li>
<li>CX -&gt; CH CL</li>
<li>DX -&gt; DH DL</li>
</ul>
<p>把一个16位的寄存器想象成一个16个格子的格子间，从格子间最右边开始的第一个格子的序号为0，最左边的最后一个格子序号为15。0~7称为 <em>低8位</em> 8~15称为 <em>高8位</em>。</p>
<p>独立的两个8位寄存器（类似 AH AL） 被命名为 某H 的是存储高位的寄存器，某L 的是存储地位的寄存器。</p>
<h1 id="字在寄存器中的存储"><a href="#字在寄存器中的存储" class="headerlink" title="字在寄存器中的存储"></a>字在寄存器中的存储</h1><p>一个字（word）由两个字节组成，这两个字分别为这个字的高位字节和地位字节。</p>
<p>比如十进制数 20000，它的二进制为 0100111000100000, 他就可以保存在一个16位的AX寄存器中，AH保存了它的高8位，AL则保存了他低8位。</p>
<ul>
<li>AH -&gt; 01001110 B = 78 = 4E H</li>
<li>AL -&gt; 00100000 B = 32 = 20 H</li>
</ul>
<p>有趣的是，如果把 AH 和 AL 的16进制值拼起来就等于 4E20 恰好等于 20000 的16进制值，这就是16进制表示的好处。</p>
<h1 id="几条汇编指令"><a href="#几条汇编指令" class="headerlink" title="几条汇编指令"></a>几条汇编指令</h1><ul>
<li><code>mov ax,18</code> 把 18 送入寄存器ax</li>
<li><code>add ax,8</code> 在 AX 寄存器原来的值上加 8</li>
<li><code>mov ax,bx</code> 把 BX 寄存器的值送入AX寄存器</li>
<li><code>add ax,bx</code> AX寄存器原来的值加上BX寄存器的值，结果保存在AX中</li>
</ul>
<p>假设 AX = 8226 H ，BX = 8226 H, 如果执行 <code>add ax,bx</code> 即 8226h + 8226h 的值赋给 AX 寄存器，计算下，它们相加的结果为 1044C，转换成二进制是：<code>10000010000111111</code> 17位，所以装不下，要去掉最高位的1，所以最终保存在寄存器 AX 中的值为 044C。</p>
<p>假设 AX = 00c5 BX = 4026h 执行 <code>add al,93H</code>, 也就是说在 AX 寄存器的低8位即 c5 + 93h = 158h , 但是 AX 的低8位寄存器 AL 只能存8位二进制值也就是2位16进制值，所以必须舍弃最高位的1，于是 AL 保存的值为 58h 所以 AX寄存器的值也就成了 AH的值 和 AL的值 拼在一起的值 0058h。</p>
<p><em>注意事项：当使用 <code>mov</code> 或者 <code>add</code> 等指令时，要注意两个操作对象位数是否一致，比如 ax 不能和 bl 放在一起</em></p>
<h1 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h1><p>CPU 访问内存单元的时候，需要告诉内存要访问的这个单元的地址是多少，CPU是通过地址总线来把物理地址送入内存的。</p>
<p>8086 CPU 是16位的，这个16位代表：</p>
<ul>
<li>运算器一次可以运算16位的数据</li>
<li>寄存器最大的宽度也是16</li>
<li>寄存器和运算器之间的通路也是16</li>
</ul>
<p>综上，在CPU的内部，能够一次性处理、传输和存储的数据只能是16位，那么 CPU 需要通过地址总线把要访问的内存单元的地址输入给内存，然而8086实际上地址总线的宽度是20，也就是说一次可以支持传输20位的数据，换算一下它支持的寻址最大为2的20次方，即1MB左右，这时问题来了，16位的 CPU 和 20位的 地址总线，怎么看都浪费地址总线的宽度了，所以这时CPU就需要来合成一个20位的地址来输出。</p>
<h1 id="合成物理地址"><a href="#合成物理地址" class="headerlink" title="合成物理地址"></a>合成物理地址</h1><p>由于16位的CPU一次性写不下20位的数据，于是就只能用两个16位的地址，通过某个方法来合成一个20位的地址。</p>
<p>首先，我们把两个16位的地址分别称为段地址和偏移地址，计算方式是</p>
<p><em>物理地址 = 段地址 </em> 16 + 偏移地址*</p>
<p>比如 段地址为：1230h 偏移地址为 00c8，则物理地址等于</p>
<p>1230h * 16 + 00c8 = 123c8</p>
<h1 id="寄存器-CS-和-IP"><a href="#寄存器-CS-和-IP" class="headerlink" title="寄存器 CS 和 IP"></a>寄存器 CS 和 IP</h1><p>CS 和 IP 是 8086 最关键的两个寄存器，他们指示了当前CPU要读取指令的地址， CS 为代码段寄存器（存放了段地址）， IP 指令指正寄存器（存放了偏移地址）。</p>
<p>CPU 合成物理地址的原理是这样的：</p>
<p>首先 CS 和 IP 两个寄存器保存了两个16位物理地址，这两个地址将被送入地址加法器，通过上述的公式计算出物理地址，然后把物理地址送入输入输出控制电路，然后被送到地址总线，由地址总线把物理地址送入内存。具体的流程在书P26。</p>
<p>为了修改CPU要执行的指令，我们可以修改 CS 和 IP 寄存器</p>
<p><code>JMP 2AE3:3 这个指令表示修改段地址(CS)为2AE3，偏移地址为3h，CPU将会从2AE33处取指令</code></p>
<p>或者你不想修改段地址，只是修改偏移地址，你可以这样</p>
<p><code>JMP AX 表示把寄存器 AX 的值作为IP寄存器（偏移地址）的值</code></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习笔记-汇编语言/">学习笔记 汇编语言</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-终于搭好了hexo" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/27/终于搭好了hexo/" class="article-date">
  	<time datetime="2016-06-27T09:13:12.000Z" itemprop="datePublished">2016-06-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/27/终于搭好了hexo/">终于搭好了hexo</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>以后写博客就用它来写了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/随笔/">随笔</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 J0hnnny
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>