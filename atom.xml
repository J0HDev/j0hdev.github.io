<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>J0hnnny&#39;s blog</title>
  <subtitle>欢迎造访 ^_^</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-09-02T07:09:05.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>J0hnnny</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>手把手带你撸一个 YYModel 的精简版</title>
    <link href="http://yoursite.com/2016/09/02/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%92%B8%E4%B8%80%E4%B8%AA-YYModel-%E7%9A%84%E7%B2%BE%E7%AE%80%E7%89%88/"/>
    <id>http://yoursite.com/2016/09/02/手把手带你撸一个-YYModel-的精简版/</id>
    <published>2016-09-02T07:08:08.000Z</published>
    <updated>2016-09-02T07:09:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>读完这篇文章你可以自己写一个 YYModel 这样的神器，这篇文章类似一个源码解析，但不同的是，它不光光是解析，更是实战，因为我觉得学习一个东西必须要自己写一遍才算是真的学了一遍，否则即便是读完了源码印象还是不会太深刻，so，开始吧。</p>
<p><em>注：为了简单起见，我的例子只是实现了一个精简的版本，YYModel 有很多功能，我这里就实现了一个核心的功能，<code>JSON -&gt; Model</code>。</em></p>
<p><em>注：文章的最后有完整的代码</em></p>
<h2 id="从JSON映射到Model的原理"><a href="#从JSON映射到Model的原理" class="headerlink" title="从JSON映射到Model的原理"></a>从JSON映射到Model的原理</h2><p>想一下平时我们是怎么使用类似这样子的库的，当我们有一个JSON的时候，我们把所有JSON的字段（比如name、page）全部写成对应的类中的属性。然后库会自动把你JSON对应字段的值赋值到这些对应的属性里去。属性我们用 <code>@property</code> 来定义，就意味着编译器会帮你生成对应的<code>get``set</code>方法，我们使用的 <code>.</code> 其实也是在调用<code>get``set</code>方法来实现赋值的。在 Objective-C 中有一个著名的函数 <code>objc_msgSend(...)</code> 我们所有的类似 <code>[obj method]</code> 的方法调用（发送消息）都会被转换成 <code>objc_msgSend(...)</code> 的方式来调用。（具体这个函数怎么用后面再说）</p>
<p>所以对于一个库来说，要调用你这个 Model 的 <code>set</code> 方法，用 <code>objc_msgSend(...)</code> 会容易的多，所以JSON映射到Model的原理其实就是调用这个函数而已。</p>
<p>所以整个流程就是，你给我一个 Model 类，我会用 runtime 提供的各种函数来拿到你所有的属性和对应的<code>get``set</code>，判断完相应的类型以后，调用objc_msgSend(…)。说起来真的非常简单，做起来就有点麻烦…</p>
<h2 id="前期的准备工作"><a href="#前期的准备工作" class="headerlink" title="前期的准备工作"></a>前期的准备工作</h2><p>为了后面的方便，我们需要把一些关键的东西封装起来，我们需要单独封装 <code>ivar</code> <code>property</code> <code>method</code>，也就是实例变量、属性、方法，但事实上我们的这个精简版的YYModel并不需要 <code>method</code> <code>ivar</code> 的封装，为了保证完整性，我还是打算写下来。</p>
<h3 id="封装-ivar"><a href="#封装-ivar" class="headerlink" title="封装 ivar"></a>封装 ivar</h3><p>先来封装 <code>ivar</code>，看一下头文件 <code>CPClassIvarInfo.h</code>（YYModel只有4个文件，两个 <code>.h</code> 两个 <code>.m</code> 我为了让代码看起来更清楚，所以我自己在重写 YYModel 的时候把所有可以拆出来的类都分别拆成了一对<code>.h .m</code>）并把前缀改成了 CP 意思是 copy。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">#import &quot;CPCommon.h&quot;</span><br><span class="line"></span><br><span class="line">@interface CPClassIvarInfo : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign, readonly) Ivar ivar;</span><br><span class="line">@property (nonatomic, strong, readonly) NSString *name;</span><br><span class="line">@property (nonatomic, strong, readonly) NSString *typeEncoding;</span><br><span class="line">@property (nonatomic, assign, readonly) CPEncodingType type;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithIvar:(Ivar)ivar;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><code>Ivar</code> 代表一个实例变量，你所有和实例变量有关的操作都必须要把 <code>Ivar</code> 传进去，等一下就能看到。</p>
<p><code>name</code> 是这个实例变量的变量名</p>
<p><code>typeEncoding</code> 是对类型的编码，具体可以看<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="external">这里</a> 对于不同的类型就会有对应的编码，比如 <code>int</code> 就会变编码成 <code>i</code>，可以用 <code>@encode(int)</code>这样的操作来看一个类型的编码。</p>
<p><code>type</code> 是一个自定义的枚举，它描述了 YYMode 规定的类型。</p>
<h4 id="一个强大的枚举"><a href="#一个强大的枚举" class="headerlink" title="一个强大的枚举"></a>一个强大的枚举</h4><p>然后重新再创建一个文件（CPCommon），作为一个公共的文件 <code>CPEncodingType</code> 这个枚举就写在这里。</p>
<p>我们要创建的这个枚举需要一口气表示三种不同的类型，一种用于普通的类型上(<code>int double object</code>)，一种用来表示关键词(<code>const</code>)，一种表示 Property 的属性（<code>Nonatomic</code> <code>weak</code> <code>retain</code>）。</p>
<p>我们可以用位运算符来搞定这三种类型，用8位的枚举值来表示第一种，16位的表示第二种，24位的表示第三种，然后为了区别这三种类型都属于多少位的，我们可以分别搞三个 mask ，做一个该类型和某一个 mask 的与(&amp;)的操作就可以知道这个类型是具体是哪一个类型了，例子在后面。</p>
<p>这个枚举我们可以这样定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, CPEncodingType) &#123;</span><br><span class="line">    CPEncodingTypeMask       = 0xFF, //8 bit</span><br><span class="line">    CPEncodingTypeUnknown    = 0, </span><br><span class="line">    CPEncodingTypeVoid       = 1, </span><br><span class="line">    CPEncodingTypeBool       = 2, </span><br><span class="line">    CPEncodingTypeInt8       = 3, </span><br><span class="line">    CPEncodingTypeUInt8      = 4, </span><br><span class="line">    CPEncodingTypeInt16      = 5, </span><br><span class="line">    CPEncodingTypeUInt16     = 6, </span><br><span class="line">    CPEncodingTypeInt32      = 7, </span><br><span class="line">    CPEncodingTypeUInt32     = 8, </span><br><span class="line">    CPEncodingTypeInt64      = 9, </span><br><span class="line">    CPEncodingTypeUInt64     = 10,</span><br><span class="line">    CPEncodingTypeFloat      = 11,</span><br><span class="line">    CPEncodingTypeDouble     = 12,</span><br><span class="line">    CPEncodingTypeLongDouble = 13,</span><br><span class="line">    CPEncodingTypeObject     = 14,</span><br><span class="line">    CPEncodingTypeClass      = 15,</span><br><span class="line">    CPEncodingTypeSEL        = 16,</span><br><span class="line">    CPEncodingTypeBlock      = 17,</span><br><span class="line">    CPEncodingTypePointer    = 18,</span><br><span class="line">    CPEncodingTypeStruct     = 19,</span><br><span class="line">    CPEncodingTypeUnion      = 20,</span><br><span class="line">    CPEncodingTypeCString    = 21,</span><br><span class="line">    CPEncodingTypeCArray     = 22,</span><br><span class="line">    </span><br><span class="line">    CPEncodingTypeQualifierMask   = 0xFF00,  //16 bit</span><br><span class="line">    CPEncodingTypeQualifierConst  = 1 &lt;&lt; 8,  </span><br><span class="line">    CPEncodingTypeQualifierIn     = 1 &lt;&lt; 9,  </span><br><span class="line">    CPEncodingTypeQualifierInout  = 1 &lt;&lt; 10, </span><br><span class="line">    CPEncodingTypeQualifierOut    = 1 &lt;&lt; 11, </span><br><span class="line">    CPEncodingTypeQualifierBycopy = 1 &lt;&lt; 12, </span><br><span class="line">    CPEncodingTypeQualifierByref  = 1 &lt;&lt; 13, </span><br><span class="line">    CPEncodingTypeQualifierOneway = 1 &lt;&lt; 14,</span><br><span class="line">    </span><br><span class="line">    CPEncodingTypePropertyMask         = 0xFF0000, // 24 bit</span><br><span class="line">    CPEncodingTypePropertyReadonly     = 1 &lt;&lt; 16, </span><br><span class="line">    CPEncodingTypePropertyCopy         = 1 &lt;&lt; 17, </span><br><span class="line">    CPEncodingTypePropertyRetain       = 1 &lt;&lt; 18, </span><br><span class="line">    CPEncodingTypePropertyNonatomic    = 1 &lt;&lt; 19, </span><br><span class="line">    CPEncodingTypePropertyWeak         = 1 &lt;&lt; 20, </span><br><span class="line">    CPEncodingTypePropertyCustomGetter = 1 &lt;&lt; 21, </span><br><span class="line">    CPEncodingTypePropertyCustomSetter = 1 &lt;&lt; 22, </span><br><span class="line">    CPEncodingTypePropertyDynamic      = 1 &lt;&lt; 23,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>比如有一个类型是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPEncodingType type = CPEncodingTypeDouble;</span><br></pre></td></tr></table></figure>
<p>假设我们并不知道它是 <code>CPEncodingTypeDouble</code> 类型，那我们要怎么样才能知道它是什么类型呢？只要这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%lu&quot;,type &amp; CPEncodingTypeMask);</span><br></pre></td></tr></table></figure>
<p>输出： 12</p>
<p>在枚举的定义中 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPEncodingTypeDouble     = 12,</span><br></pre></td></tr></table></figure>
<p>假设这个枚举值有很多种混在一起</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CPEncodingType type = CPEncodingTypeDouble | CPEncodingTypePropertyRetain;</span><br><span class="line">NSLog(@&quot;%lu&quot;,type &amp; CPEncodingTypePropertyMask); //输出 262144 (1&lt;&lt;18的十进制表示)</span><br><span class="line">NSLog(@&quot;%lu&quot;,type &amp; CPEncodingTypeMask); //输出 12</span><br></pre></td></tr></table></figure>
<p>可能有人知道这种神奇的用法，但在我读YYModel之前我没用过这种方法（技术比较菜）。</p>
<p>然后还有一个函数，这个函数可以把类型编码（Type Encoding）转换成刚才的枚举值，很简单却很长的一个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">CPEncodingType CPEncodingGetType(const char *typeEncoding) &#123;</span><br><span class="line">    char *type = (char *)typeEncoding;</span><br><span class="line">    if (!type) return CPEncodingTypeUnknown;</span><br><span class="line">    size_t len = strlen(type);</span><br><span class="line">    if (len == 0) return CPEncodingTypeUnknown;</span><br><span class="line">    </span><br><span class="line">    CPEncodingType qualifier = 0;</span><br><span class="line">    bool prefix = true;</span><br><span class="line">    while (prefix) &#123;</span><br><span class="line">        switch (*type) &#123;</span><br><span class="line">            case &apos;r&apos;: &#123;</span><br><span class="line">                qualifier |= CPEncodingTypeQualifierConst;</span><br><span class="line">                type++;</span><br><span class="line">            &#125; break;</span><br><span class="line">            case &apos;n&apos;: &#123;</span><br><span class="line">                qualifier |= CPEncodingTypeQualifierIn;</span><br><span class="line">                type++;</span><br><span class="line">            &#125; break;</span><br><span class="line">            case &apos;N&apos;: &#123;</span><br><span class="line">                qualifier |= CPEncodingTypeQualifierInout;</span><br><span class="line">                type++;</span><br><span class="line">            &#125; break;</span><br><span class="line">            case &apos;o&apos;: &#123;</span><br><span class="line">                qualifier |= CPEncodingTypeQualifierOut;</span><br><span class="line">                type++;</span><br><span class="line">            &#125; break;</span><br><span class="line">            case &apos;O&apos;: &#123;</span><br><span class="line">                qualifier |= CPEncodingTypeQualifierBycopy;</span><br><span class="line">                type++;</span><br><span class="line">            &#125; break;</span><br><span class="line">            case &apos;R&apos;: &#123;</span><br><span class="line">                qualifier |= CPEncodingTypeQualifierByref;</span><br><span class="line">                type++;</span><br><span class="line">            &#125; break;</span><br><span class="line">            case &apos;V&apos;: &#123;</span><br><span class="line">                qualifier |= CPEncodingTypeQualifierOneway;</span><br><span class="line">                type++;</span><br><span class="line">            &#125; break;</span><br><span class="line">            default: &#123; prefix = false; &#125; break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    len = strlen(type);</span><br><span class="line">    if (len == 0) return CPEncodingTypeUnknown | qualifier;</span><br><span class="line">    </span><br><span class="line">    switch (*type) &#123;</span><br><span class="line">        case &apos;v&apos;: return CPEncodingTypeVoid | qualifier;</span><br><span class="line">        case &apos;B&apos;: return CPEncodingTypeBool | qualifier;</span><br><span class="line">        case &apos;c&apos;: return CPEncodingTypeInt8 | qualifier;</span><br><span class="line">        case &apos;C&apos;: return CPEncodingTypeUInt8 | qualifier;</span><br><span class="line">        case &apos;s&apos;: return CPEncodingTypeInt16 | qualifier;</span><br><span class="line">        case &apos;S&apos;: return CPEncodingTypeUInt16 | qualifier;</span><br><span class="line">        case &apos;i&apos;: return CPEncodingTypeInt32 | qualifier;</span><br><span class="line">        case &apos;I&apos;: return CPEncodingTypeUInt32 | qualifier;</span><br><span class="line">        case &apos;l&apos;: return CPEncodingTypeInt32 | qualifier;</span><br><span class="line">        case &apos;L&apos;: return CPEncodingTypeUInt32 | qualifier;</span><br><span class="line">        case &apos;q&apos;: return CPEncodingTypeInt64 | qualifier;</span><br><span class="line">        case &apos;Q&apos;: return CPEncodingTypeUInt64 | qualifier;</span><br><span class="line">        case &apos;f&apos;: return CPEncodingTypeFloat | qualifier;</span><br><span class="line">        case &apos;d&apos;: return CPEncodingTypeDouble | qualifier;</span><br><span class="line">        case &apos;D&apos;: return CPEncodingTypeLongDouble | qualifier;</span><br><span class="line">        case &apos;#&apos;: return CPEncodingTypeClass | qualifier;</span><br><span class="line">        case &apos;:&apos;: return CPEncodingTypeSEL | qualifier;</span><br><span class="line">        case &apos;*&apos;: return CPEncodingTypeCString | qualifier;</span><br><span class="line">        case &apos;^&apos;: return CPEncodingTypePointer | qualifier;</span><br><span class="line">        case &apos;[&apos;: return CPEncodingTypeCArray | qualifier;</span><br><span class="line">        case &apos;(&apos;: return CPEncodingTypeUnion | qualifier;</span><br><span class="line">        case &apos;&#123;&apos;: return CPEncodingTypeStruct | qualifier;</span><br><span class="line">        case &apos;@&apos;: &#123;</span><br><span class="line">            if (len == 2 &amp;&amp; *(type + 1) == &apos;?&apos;)</span><br><span class="line">                return CPEncodingTypeBlock | qualifier;</span><br><span class="line">            else</span><br><span class="line">                return CPEncodingTypeObject | qualifier;</span><br><span class="line">        &#125;</span><br><span class="line">        default: return CPEncodingTypeUnknown | qualifier;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，不用多讲了。</p>
<p>回到 CPClassIvarInfo 刚才我们只给出了头文件，现在看一下实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithIvar:(Ivar)ivar &#123;</span><br><span class="line">    if (!ivar)&#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self)&#123;</span><br><span class="line">        _ivar = ivar;</span><br><span class="line">        const char *name = ivar_getName(ivar);</span><br><span class="line">        if (name)&#123;</span><br><span class="line">            _name = [NSString stringWithUTF8String:name];</span><br><span class="line">        &#125;</span><br><span class="line">        const char *typeEncoding = ivar_getTypeEncoding(ivar);</span><br><span class="line">        if (typeEncoding)&#123;</span><br><span class="line">            _typeEncoding = [NSString stringWithUTF8String:typeEncoding];</span><br><span class="line">            _type = CPEncodingGetType(typeEncoding);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有一个方法，这里就用到了两个 runtime 函数 <code>ivar_getName(ivar)</code> 和 <code>ivar_getTypeEncoding(ivar)</code> 传入 ivar 就行。</p>
<h3 id="封装Method"><a href="#封装Method" class="headerlink" title="封装Method"></a>封装Method</h3><p>然后看一下对于 Method 的封装，看一下头文件（CPClassMethodInfo.h）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface CPClassMethodInfo : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign, readonly) Method method;</span><br><span class="line">@property (nonatomic, strong, readonly) NSString *name;</span><br><span class="line">@property (nonatomic, assign, readonly) SEL sel;</span><br><span class="line">@property (nonatomic, assign, readonly) IMP imp;</span><br><span class="line">@property (nonatomic, strong, readonly) NSString *typeEncoding;</span><br><span class="line">@property (nonatomic, strong, readonly) NSString *returnTypeEncoding;</span><br><span class="line">@property (nullable, nonatomic, strong, readonly) NSArray&lt;NSString *&gt; *argumentTypeEncodings;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithMethod:(Method)method;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h4 id="Objective-C-的-Optional"><a href="#Objective-C-的-Optional" class="headerlink" title="Objective-C 的 Optional"></a>Objective-C 的 Optional</h4><p><code>NS_ASSUME_NONNULL_BEGIN</code> 和 <code>NS_ASSUME_NONNULL_END</code> 是成对出现的，因为 Swift 可以和 Objective-C 混用，但是 Swift 有 Optional 类型，而 Objective-C 没有这样的概念，为了和 Swift 保持一致，现在 Objective-C 有了 <code>_Nullable 可空</code> <code>_Nonnull不可空</code>这样的关键字，这两个关键字可以在变量、方法返回值、方法参数上使用，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSString  * _Nonnull string;</span><br><span class="line"></span><br><span class="line">- (NSString * _Nonnull)method:(NSString *_Nonnull)string;</span><br></pre></td></tr></table></figure>
<p>还有另外一对 <code>nullable</code> <code>nonnull</code>，它们可以这样用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property (nullable, nonatomic, strong) NSString  *string;</span><br><span class="line"></span><br><span class="line">- (nullable NSString *)method:(nullable NSString *)string;</span><br></pre></td></tr></table></figure>
<p>对了，这些关键词只能用在指针上，其他类型是不能用的。</p>
<p>当你一旦在某个地方写上关键词 <code>nullable</code>的时候，编译器就会提出警告，Pointer is missing a nullability type specifier (_Nonnull, _Nullable, or _Null_unspecified) 然后你就可以加上<code>NS_ASSUME_NONNULL_BEGIN</code> 和 <code>NS_ASSUME_NONNULL_END</code>来表示只有我标记为 <code>nullable</code> 的地方才可空，其余地方都是 <code>nonnull</code>。</p>
<p>回到刚才的头文件代码，<code>method</code> 表示一个方法</p>
<p><code>name</code> 很明显就是方法名了</p>
<p><code>sel</code> 和 <code>imp</code> 是一个对应关系，一个对象的所有方法都会保存在一张表里，通过 <code>sel</code> 就能找到这个方法的 <code>imp</code>，我讲的可能有点简单，如果想要深入的了解可以查一下文档或者博客。</p>
<p><code>typeEncoding</code> 又是一个编码，这里是参数和返回值的编码</p>
<p><code>returnTypeEncoding</code> 返回值的编码</p>
<p><code>argumentTypeEncodings</code> 所有参数的编码</p>
<p>实现还是很简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithMethod:(Method)method &#123;</span><br><span class="line">    if (!method) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self)&#123;</span><br><span class="line">        _method = method;</span><br><span class="line">        _sel = method_getName(method);</span><br><span class="line">        _imp = method_getImplementation(method);</span><br><span class="line">        const char *name = sel_getName(_sel);</span><br><span class="line">        if (name) &#123;</span><br><span class="line">            _name = [NSString stringWithUTF8String:name];</span><br><span class="line">        &#125;</span><br><span class="line">        const char *typeEncoding = method_getTypeEncoding(method);</span><br><span class="line">        if (typeEncoding) &#123;</span><br><span class="line">            _typeEncoding = [NSString stringWithUTF8String:typeEncoding];</span><br><span class="line">        &#125;</span><br><span class="line">        char *returnTypeEncoding = method_copyReturnType(method);</span><br><span class="line">        if (returnTypeEncoding) &#123;</span><br><span class="line">            _returnTypeEncoding = [NSString stringWithUTF8String:returnTypeEncoding];</span><br><span class="line">            free(returnTypeEncoding);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //得到参数的数目，遍历取得所有参数的类型</span><br><span class="line">        unsigned int count = method_getNumberOfArguments(method);</span><br><span class="line">        if (count &gt; 0) &#123;</span><br><span class="line">            NSMutableArray *types = [[NSMutableArray alloc] initWithCapacity:10];</span><br><span class="line">            for (unsigned int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">                char *argumentsType = method_copyArgumentType(method, i);</span><br><span class="line">                NSString *type = argumentsType ? [NSString stringWithUTF8String:argumentsType] : nil;</span><br><span class="line">                [types addObject:type ? type : @&quot;&quot;];</span><br><span class="line">                if (argumentsType) &#123;</span><br><span class="line">                    free(argumentsType);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            _argumentTypeEncodings = types;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和前面套路一样。</p>
<h3 id="封装-Property"><a href="#封装-Property" class="headerlink" title="封装 Property"></a>封装 Property</h3><p>老样子，看头</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">#import &quot;CPCommon.h&quot;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface CPClassPropertyInfo : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign, readonly) objc_property_t property;</span><br><span class="line">@property (nonatomic, strong, readonly) NSString *name;</span><br><span class="line">@property (nonatomic, assign, readonly) CPEncodingType type;</span><br><span class="line">@property (nonatomic, strong, readonly) NSString *typdEncoding;</span><br><span class="line">@property (nonatomic, strong, readonly) NSString *ivarName;</span><br><span class="line">@property (nullable, nonatomic, assign, readonly) Class cls;</span><br><span class="line">@property (nonatomic, assign, readonly) SEL getter;</span><br><span class="line">@property (nonatomic, assign, readonly) SEL setter;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithProperty:(objc_property_t)property;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>这是在精简版的YYModel中会用到的一个类，这里尤其要注意的是<code>type</code>和<code>typdEncoding</code>两个属性，希望读者能够仔细调试一下，看一下主要的一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">CPEncodingType type = 0;</span><br><span class="line">unsigned int outCount;</span><br><span class="line">objc_property_attribute_t *attrs = property_copyAttributeList(property, &amp;outCount);</span><br><span class="line">//遍历所有的Property的属性</span><br><span class="line">for (unsigned int i = 0; i &lt; outCount; i++) &#123;</span><br><span class="line">    switch (attrs[i].name[0]) &#123;</span><br><span class="line">        case &apos;T&apos;:</span><br><span class="line">            if (attrs[i].value) &#123;</span><br><span class="line">                _typdEncoding = [NSString stringWithUTF8String:attrs[i].value];</span><br><span class="line">                type = CPEncodingGetType(attrs[i].value);</span><br><span class="line">                </span><br><span class="line">                if((type &amp; CPEncodingTypeMask) == CPEncodingTypeObject)&#123;</span><br><span class="line">                    //如果该类型为一个对象 比如 @&quot;NSString&quot; ,截取中间的，结果为 NSString，目的是为了得到这个类的 Class</span><br><span class="line">                    size_t len = strlen(attrs[i].value);</span><br><span class="line">                    if (len &gt; 3) &#123;</span><br><span class="line">                        char name[len - 2];</span><br><span class="line">                        name[len - 3] = &apos;\0&apos;;</span><br><span class="line">                        memcpy(name, attrs[i].value + 2, len - 3);</span><br><span class="line">                        _cls = objc_getClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">            </span><br><span class="line">            case &apos;V&apos;:</span><br><span class="line">                if (attrs[i].value) &#123;</span><br><span class="line">                    _ivarName = [NSString stringWithUTF8String:attrs[i].value];</span><br><span class="line">                &#125;</span><br><span class="line">            break;</span><br><span class="line">            </span><br><span class="line">        case &apos;R&apos;:</span><br><span class="line">            type |= CPEncodingTypePropertyReadonly;</span><br><span class="line">            break;</span><br><span class="line">            </span><br><span class="line">        case &apos;C&apos;:</span><br><span class="line">            type |= CPEncodingTypePropertyCopy;</span><br><span class="line">            break;</span><br><span class="line">            </span><br><span class="line">        case &apos;&amp;&apos;:</span><br><span class="line">            type |= CPEncodingTypePropertyRetain;</span><br><span class="line">            break;</span><br><span class="line">            </span><br><span class="line">        case &apos;N&apos;:</span><br><span class="line">            type |= CPEncodingTypePropertyNonatomic;</span><br><span class="line">            break;</span><br><span class="line">            </span><br><span class="line">        case &apos;D&apos;:</span><br><span class="line">            type |= CPEncodingTypePropertyDynamic;</span><br><span class="line">            break;</span><br><span class="line">            </span><br><span class="line">        case &apos;W&apos;:</span><br><span class="line">            type |= CPEncodingTypePropertyWeak;</span><br><span class="line">            break;</span><br><span class="line">            </span><br><span class="line">        case  &apos;G&apos;:</span><br><span class="line">            type |= CPEncodingTypePropertyCustomGetter;</span><br><span class="line">            if (attrs[i].value) &#123;</span><br><span class="line">                _getter = NSSelectorFromString([NSString stringWithUTF8String:attrs[i].value]);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        </span><br><span class="line">        case &apos;S&apos;:</span><br><span class="line">            type |= CPEncodingTypePropertyCustomSetter;</span><br><span class="line">            if (attrs[i].value) &#123;</span><br><span class="line">                _setter = NSSelectorFromString([NSString stringWithUTF8String:attrs[i].value]);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">            </span><br><span class="line">        default: break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过<code>property_copyAttributeList</code>这个函数得到一个指向一个结构体<code>objc_property_attribute_t</code>的指针，这个结构体的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    const char *name;           /**&lt; The name of the attribute */</span><br><span class="line">    const char *value;          /**&lt; The value of the attribute (usually empty) */</span><br><span class="line">&#125; objc_property_attribute_t;</span><br></pre></td></tr></table></figure>
<p>说是一个指针，其实它是一个结构体数组，指针指向的其实是这个数组第一个元素。</p>
<p>这个结构体表示的是一个 Property 的属性，关于 Property 的类型编码可以看<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW5" target="_blank" rel="external">这里</a></p>
<p>要说清这个数组里每一个结构体元素的<code>name</code>和<code>value</code>都存了什么，我们可以看一下下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class cls = objc_getClass(&quot;CPBook&quot;);</span><br><span class="line">objc_property_t property = class_getProperty(cls, &quot;name&quot;);</span><br><span class="line">const char* attr = property_getAttributes(property);</span><br><span class="line">NSLog(@&quot;%s&quot;,attr);</span><br></pre></td></tr></table></figure>
<p>这里比如有一个类是 CPBook ，我们通过这个类的 Class 来拿到一个叫做 name 的 Property，然后在拿到这个 Property 所有属性，输出的结果是 <code>T@&quot;NSString&quot;,&amp;,N,V_name</code></p>
<p>其实，我们用和上面一样返回一个结构体数组的方式来获取这个 Property 的属性的话，那么这个结构体应该会有4个元素。</p>
<p>第一个元素 <code>name = T</code>，<code>value = @&quot;NSString&quot;</code>，第二个元素 <code>name = &amp;</code>，<code>value 没有值</code>，第三个元素 <code>name = N</code>，<code>value 仍然没有值</code>，第四个元素 <code>name = V</code>，<code>value = _name</code>。不信可以运行一下下面的代码来看看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Class cls = objc_getClass(&quot;CPBook&quot;);</span><br><span class="line">unsigned int acount;</span><br><span class="line">objc_property_t *prop = class_copyPropertyList(cls, &amp;acount);</span><br><span class="line">    </span><br><span class="line">objc_property_attribute_t *attr1 = property_copyAttributeList(prop[2], &amp;acount);</span><br><span class="line">NSLog(@&quot;%s&quot;,attr1[0].name);</span><br><span class="line">NSLog(@&quot;%s&quot;,attr1[0].value);</span><br><span class="line">NSLog(@&quot;-------------------&quot;);</span><br><span class="line">NSLog(@&quot;%s&quot;,attr1[1].name);</span><br><span class="line">NSLog(@&quot;%s&quot;,attr1[1].value);</span><br><span class="line">NSLog(@&quot;-------------------&quot;);</span><br><span class="line">NSLog(@&quot;%s&quot;,attr1[2].name);</span><br><span class="line">NSLog(@&quot;%s&quot;,attr1[2].value);</span><br><span class="line">NSLog(@&quot;-------------------&quot;);</span><br><span class="line">NSLog(@&quot;%s&quot;,attr1[3].name);</span><br><span class="line">NSLog(@&quot;%s&quot;,attr1[3].value);</span><br></pre></td></tr></table></figure>
<p>至于 V N &amp; 这样的符号是什么意思，可以打开上面给出的链接自己看一下文档，一看便知。</p>
<p>这样一来在 switch 分支中，只要匹配到 T 就能得到这个 Property 的类型是什么，这样就可以得到这个类型的 Type Encoding，并且能够得到该类的 Class。只要匹配到 V 就能得到这个 Property 实例变量名。</p>
<p>该类全部代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithProperty:(objc_property_t)property &#123;</span><br><span class="line">    if (!property) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _property = property;</span><br><span class="line">        const char *name = property_getName(property);</span><br><span class="line">        if (name) &#123;</span><br><span class="line">            _name = [NSString stringWithUTF8String:name];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        CPEncodingType type = 0;</span><br><span class="line">        unsigned int outCount;</span><br><span class="line">        objc_property_attribute_t *attrs = property_copyAttributeList(property, &amp;outCount);</span><br><span class="line">        //遍历所有的Property的属性</span><br><span class="line">        for (unsigned int i = 0; i &lt; outCount; i++) &#123;</span><br><span class="line">            switch (attrs[i].name[0]) &#123;</span><br><span class="line">                case &apos;T&apos;:</span><br><span class="line">                    if (attrs[i].value) &#123;</span><br><span class="line">                        _typdEncoding = [NSString stringWithUTF8String:attrs[i].value];</span><br><span class="line">                        type = CPEncodingGetType(attrs[i].value);</span><br><span class="line">                        </span><br><span class="line">                        if((type &amp; CPEncodingTypeMask) == CPEncodingTypeObject)&#123;</span><br><span class="line">                            //如果该类型为一个对象 比如 @&quot;NSString&quot; ,截取中间的，结果为 NSString，目的是为了得到这个类的 Class</span><br><span class="line">                            size_t len = strlen(attrs[i].value);</span><br><span class="line">                            if (len &gt; 3) &#123;</span><br><span class="line">                                char name[len - 2];</span><br><span class="line">                                name[len - 3] = &apos;\0&apos;;</span><br><span class="line">                                memcpy(name, attrs[i].value + 2, len - 3);</span><br><span class="line">                                _cls = objc_getClass(name);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                    </span><br><span class="line">                    case &apos;V&apos;:</span><br><span class="line">                        if (attrs[i].value) &#123;</span><br><span class="line">                            _ivarName = [NSString stringWithUTF8String:attrs[i].value];</span><br><span class="line">                        &#125;</span><br><span class="line">                    break;</span><br><span class="line">                    </span><br><span class="line">                case &apos;R&apos;:</span><br><span class="line">                    type |= CPEncodingTypePropertyReadonly;</span><br><span class="line">                    break;</span><br><span class="line">                    </span><br><span class="line">                case &apos;C&apos;:</span><br><span class="line">                    type |= CPEncodingTypePropertyCopy;</span><br><span class="line">                    break;</span><br><span class="line">                    </span><br><span class="line">                case &apos;&amp;&apos;:</span><br><span class="line">                    type |= CPEncodingTypePropertyRetain;</span><br><span class="line">                    break;</span><br><span class="line">                    </span><br><span class="line">                case &apos;N&apos;:</span><br><span class="line">                    type |= CPEncodingTypePropertyNonatomic;</span><br><span class="line">                    break;</span><br><span class="line">                    </span><br><span class="line">                case &apos;D&apos;:</span><br><span class="line">                    type |= CPEncodingTypePropertyDynamic;</span><br><span class="line">                    break;</span><br><span class="line">                    </span><br><span class="line">                case &apos;W&apos;:</span><br><span class="line">                    type |= CPEncodingTypePropertyWeak;</span><br><span class="line">                    break;</span><br><span class="line">                    </span><br><span class="line">                case  &apos;G&apos;:</span><br><span class="line">                    type |= CPEncodingTypePropertyCustomGetter;</span><br><span class="line">                    if (attrs[i].value) &#123;</span><br><span class="line">                        _getter = NSSelectorFromString([NSString stringWithUTF8String:attrs[i].value]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                </span><br><span class="line">                case &apos;S&apos;:</span><br><span class="line">                    type |= CPEncodingTypePropertyCustomSetter;</span><br><span class="line">                    if (attrs[i].value) &#123;</span><br><span class="line">                        _setter = NSSelectorFromString([NSString stringWithUTF8String:attrs[i].value]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                    </span><br><span class="line">                default: break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (attrs) &#123;</span><br><span class="line">            free(attrs);</span><br><span class="line">            attrs = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        _type = type;</span><br><span class="line">        </span><br><span class="line">        if (_name.length) &#123;</span><br><span class="line">            if (!_getter) &#123;</span><br><span class="line">                _getter = NSSelectorFromString(_name);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!_setter) &#123;</span><br><span class="line">                _setter = NSSelectorFromString([NSString stringWithFormat:@&quot;set%@%@:&quot;,[_name substringToIndex:1].uppercaseString, [_name substringFromIndex:1]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，我们就有了 ivar Method Property 的封装类。接下来，我们需要一个叫做<code>CPClassInfo</code>的类，来封装一些类的信息，并且把以上三个类也封装进去，用来描述整个类。</p>
<h3 id="封装-Class"><a href="#封装-Class" class="headerlink" title="封装 Class"></a>封装 Class</h3><p>继续看头：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@class CPClassIvarInfo;</span><br><span class="line">@class CPClassMethodInfo;</span><br><span class="line">@class CPClassPropertyInfo;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface CPClassInfo : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign, readonly) Class cls;</span><br><span class="line">@property (nonatomic, assign, readonly) Class superClass;</span><br><span class="line">@property (nonatomic, assign, readonly) Class metaClass;</span><br><span class="line">@property (nonatomic, readonly) BOOL isMeta;</span><br><span class="line">@property (nonatomic, strong, readonly) NSString *name;</span><br><span class="line">@property (nullable, nonatomic, strong, readonly) CPClassInfo *superClassInfo;</span><br><span class="line">@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, CPClassIvarInfo *&gt; *ivarInfos;</span><br><span class="line">@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, CPClassMethodInfo *&gt; *methodInfos;</span><br><span class="line">@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, CPClassPropertyInfo *&gt; *propertyInfos;</span><br><span class="line"></span><br><span class="line">- (void)setNeedUpadte;</span><br><span class="line">- (BOOL)needUpdate;</span><br><span class="line">+ (nullable instancetype)classInfoWithClass:(Class)cls;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><code>Class</code> 类型用来描述一个类，你可以使用 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">model.class</span><br><span class="line">[model class]</span><br><span class="line">[CPTestModel class]</span><br><span class="line">object_getClass(model)</span><br></pre></td></tr></table></figure>
<p>等方法来取到这个 Class。·<em>注意<code>object_getClass()</code>和其他方式 有些不同具体看<a href="http://www.jianshu.com/p/ae5c32708bc6" target="_blank" rel="external">这里</a></em></p>
<p>其余的 Property 不用多介绍了，看到它们的名字就大概能猜到干嘛的了。</p>
<p>最后的几个 <code>NSDictionary</code> 用来存所有的 ivar Method Property。</p>
<p>有些时候，一个类有可能被更改，可能改掉了方法或者是 Property，那么这时候应该通知<code>CPClassInfo</code>来重新获取到更改过后的类的信息。所以我们有两个相关的方法来实现这个目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)setNeedUpadte;</span><br><span class="line">- (BOOL)needUpdate;</span><br></pre></td></tr></table></figure>
<p>先来看一下初始化方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithClass:(Class)cls&#123;</span><br><span class="line">    if (!cls) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _cls = cls;</span><br><span class="line">        _superClass = class_getSuperclass(cls);</span><br><span class="line">        _isMeta = class_isMetaClass(cls);</span><br><span class="line">        if (_isMeta) &#123;</span><br><span class="line">            _metaClass = objc_getMetaClass(class_getName(cls));</span><br><span class="line">        &#125;</span><br><span class="line">        _name = NSStringFromClass(cls);</span><br><span class="line">        [self _update];</span><br><span class="line">        </span><br><span class="line">        _superClassInfo = [self.class classInfoWithClass:_superClass];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你没看错，这和头文件定义的<code>classInfoWithClass:</code>不是一个方法，头文件定义的那个方法用来缓存，因为实例化这个方法还是有点开销的，所以没有必要每一次都去实例化。</p>
<p>这里有一个 <code>_update</code> 方法，刚才说过，如果这个类会在某一个时刻发生变化，应该通知，收到通知后，我们去执行一些更新的操作，所以把会发生变化的一部分代码单独拿出来更好，现在看一下 <code>_update</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">- (void)_update&#123;</span><br><span class="line">    _ivarInfos = nil;</span><br><span class="line">    _propertyInfos = nil;</span><br><span class="line">    _methodInfos = nil;</span><br><span class="line">    </span><br><span class="line">    unsigned int ivarCount = 0;</span><br><span class="line">    Ivar *ivars = class_copyIvarList(self.cls, &amp;ivarCount);</span><br><span class="line">    if (ivars) &#123;</span><br><span class="line">        _ivarInfos = [NSMutableDictionary new];</span><br><span class="line">        for (unsigned int i = 0; i &lt; ivarCount; i++) &#123;</span><br><span class="line">            CPClassIvarInfo *ivarInfo = [[CPClassIvarInfo alloc] initWithIvar:ivars[i]];</span><br><span class="line">            if (ivarInfo.name) &#123;</span><br><span class="line">                [_ivarInfos setValue:ivarInfo forKey:ivarInfo.name];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        free(ivars);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    unsigned int propertyCount = 0;</span><br><span class="line">    objc_property_t *properties = class_copyPropertyList(self.cls, &amp;propertyCount);</span><br><span class="line">    if (properties) &#123;</span><br><span class="line">        _propertyInfos = [NSMutableDictionary new];</span><br><span class="line">        for (unsigned int i = 0; i &lt; propertyCount; i++) &#123;</span><br><span class="line">            CPClassPropertyInfo *propertyInfo = [[CPClassPropertyInfo alloc] initWithProperty:properties[i]];</span><br><span class="line">            if (propertyInfo.name) &#123;</span><br><span class="line">                [_propertyInfos setValue:propertyInfo forKey:propertyInfo.name];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        free(properties);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    unsigned int methodCount = 0;</span><br><span class="line">    Method *methods = class_copyMethodList(self.cls, &amp;methodCount);</span><br><span class="line">    if (methods) &#123;</span><br><span class="line">        _methodInfos = [NSMutableDictionary new];</span><br><span class="line">        for (unsigned int i = 0; i &lt; methodCount; i++) &#123;</span><br><span class="line">            CPClassMethodInfo *methodInfo = [[CPClassMethodInfo alloc] initWithMethod:methods[i]];</span><br><span class="line">            if (methodInfo.name) &#123;</span><br><span class="line">                [_methodInfos setValue:methodInfo forKey:methodInfo.name];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        free(methods);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (!_ivarInfos) &#123;</span><br><span class="line">        _ivarInfos = @&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!_methodInfos) &#123;</span><br><span class="line">        _methodInfos = @&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!_propertyInfos) &#123;</span><br><span class="line">        _propertyInfos = @&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    _needUpdate = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这个方法就是拿到一个类所有的 ivar Method Property ，一个类发生变化是不是主要就是这三个玩意的变化？</p>
<p>最后一行的 <code>_needUpdate</code> 是一个全局变量，用来标识是否发生的变化，它被定义在这里，以免暴露给外面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@implementation CPClassInfo&#123;</span><br><span class="line">    BOOL _needUpdate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当外界需要通知自己已经发生变化或者查一下是否发生变化时就调用这两个相关方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)needUpdate &#123;</span><br><span class="line">    return _needUpdate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setNeedUpadte &#123;</span><br><span class="line">    _needUpdate = YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在来看一下<code>classInfoWithClass:</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)classInfoWithClass:(Class)cls&#123;</span><br><span class="line">    if (!cls) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static NSMutableDictionary *metaCache;</span><br><span class="line">    static NSMutableDictionary *classCache;</span><br><span class="line">    static dispatch_semaphore_t lock;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        metaCache = [NSMutableDictionary dictionary];</span><br><span class="line">        classCache = [NSMutableDictionary dictionary];</span><br><span class="line">        lock = dispatch_semaphore_create(1);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span><br><span class="line">    CPClassInfo *info;</span><br><span class="line">    if (class_isMetaClass(cls)) &#123;</span><br><span class="line">        info = [metaCache valueForKey:NSStringFromClass(cls)];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        info = [classCache valueForKey:NSStringFromClass(cls)];</span><br><span class="line">    &#125;</span><br><span class="line">    if (info &amp;&amp; info-&gt;_needUpdate) &#123;</span><br><span class="line">        [info _update];</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_semaphore_signal(lock);</span><br><span class="line">    </span><br><span class="line">    if (!info) &#123;</span><br><span class="line">        info = [[CPClassInfo alloc] initWithClass:cls];</span><br><span class="line">        if (info) &#123;</span><br><span class="line">            dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span><br><span class="line">            if (info.isMeta) &#123;</span><br><span class="line">                [metaCache setValue:info forKey:NSStringFromClass(cls)];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                [classCache setValue:info forKey:NSStringFromClass(cls)];</span><br><span class="line">            &#125;</span><br><span class="line">            dispatch_semaphore_signal(lock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个 <code>NSMutableDictionary</code> 都是用来缓存的，并声明在了静态区，并且使用<code>dispatch_once()</code>来确保只会被初始化一次，然后我们需要保证线程安全，因为有可能会在多线程的场景里被用到，所以使用信号量<code>dispatch_semaphore_t</code>来搞定，信号量就像停车这样的场景一样，如果发现车满了，就等待，一有空位就放行，也就是说，当一个线程要进入临界区的时候，必须获取一个信号量，如果没有问题就进入临界区，这时另一个线程进来了，也要获取，发现信号量并没有释放，就继续等待，直到前面一个信号量被释放后，该线程才准许进入。我们可以使用<code>dispatch_semaphore_wait()</code>来获取信号量，通过<code>dispatch_semaphore_signal()</code>来释放信号量。</p>
<p>在这段代码里，我们首先确保要实例化的这个对象有没有被缓存，用传进来的 <code>cls</code> 作为 <code>key</code>，如果缓存命中，那直接取出缓存，然后判断一下，有没有更新，如果有更新，调用<code>_update</code>刷新一遍，返回，否则直接返回。缓存没有命中的话，还是乖乖的调用实例化方法，然后缓存起来。</p>
<h3 id="继续封装"><a href="#继续封装" class="headerlink" title="继续封装"></a>继续封装</h3><h4 id="CPModelPropertyMeta"><a href="#CPModelPropertyMeta" class="headerlink" title="CPModelPropertyMeta"></a>CPModelPropertyMeta</h4><p>先建一个文件，叫做 <code>CPMeta.h</code> 和 <code>CPMeta.m</code>，我们要在这里写两个类，一个是对 Property 的再次封装，一个是对 Class 的再次封装。</p>
<p>我直接把头文件代码全拿出来了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">#import &quot;CPCommon.h&quot;</span><br><span class="line">@class CPClassInfo;</span><br><span class="line">@class CPClassPropertyInfo;</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM (NSUInteger, CPEncodingNSType) &#123;</span><br><span class="line">    CPEncodingTypeNSUnknown = 0,</span><br><span class="line">    CPEncodingTypeNSString,</span><br><span class="line">    CPEncodingTypeNSMutableString,</span><br><span class="line">    CPEncodingTypeNSValue,</span><br><span class="line">    CPEncodingTypeNSNumber,</span><br><span class="line">    CPEncodingTypeNSDecimalNumber,</span><br><span class="line">    CPEncodingTypeNSData,</span><br><span class="line">    CPEncodingTypeNSMutableData,</span><br><span class="line">    CPEncodingTypeNSDate,</span><br><span class="line">    CPEncodingTypeNSURL,</span><br><span class="line">    CPEncodingTypeNSArray,</span><br><span class="line">    CPEncodingTypeNSMutableArray,</span><br><span class="line">    CPEncodingTypeNSDictionary,</span><br><span class="line">    CPEncodingTypeNSMutableDictionary,</span><br><span class="line">    CPEncodingTypeNSSet,</span><br><span class="line">    CPEncodingTypeNSMutableSet,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@interface CPModelMeta : NSObject&#123;</span><br><span class="line">    @package</span><br><span class="line">    CPClassInfo *_clsInfo;</span><br><span class="line">    NSDictionary *_mapper;</span><br><span class="line">    NSArray *_allPropertyMetas;</span><br><span class="line">    NSUInteger _keyMappedCount;</span><br><span class="line">    CPEncodingNSType _nsType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)metaWithClass:(Class)cls;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface CPModelPropertyMeta : NSObject&#123;</span><br><span class="line">    @package</span><br><span class="line">    NSString *_name;</span><br><span class="line">    CPEncodingType _type;</span><br><span class="line">    CPEncodingNSType _nsType;</span><br><span class="line">    BOOL _isCNumber;</span><br><span class="line">    Class _cls;</span><br><span class="line">    Class _genericCls;</span><br><span class="line">    SEL _getter;</span><br><span class="line">    SEL _setter;</span><br><span class="line">    BOOL _isKVCCompatible;</span><br><span class="line">    NSString *_mappedToKey;</span><br><span class="line">    CPClassPropertyInfo *_info;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)modelWithClassInfo:(CPClassInfo *)clsInfo propretyInfo:(CPClassPropertyInfo *)propertyInfo generic:(Class)generic;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>可以看到这里有两个类，姑且叫做 <code>CPModelPropertyMeta</code> 和 <code>CPModelMeta</code> 以及一个枚举，这个枚举表示一个NS的类型，因为在上一个枚举当中，我们对于对象只定义了 <code>CPEncodingTypeObject</code> 这一个类型，没法区分它到底是 <code>NSString</code> 还是别的，所以这里要细化一下，类型判断清楚很重要，如果不把这部分做好，那么在JSON转换的时候，类型上出错就直接蹦了。</p>
<p>先来看一下 <code>CPModelPropertyMeta</code> 。（在 YYModel 中，这两个类其实是和一个叫做<code>NSObject+CPModel</code>的扩展放在一起的，但是我强制把它们拆出来了，为了看起来清楚，所以我把 <code>@package</code> 的成员变量都写到了 interface 里面，这么做是不合理的，但这里为了清晰和学习起见，所以我乱来了。）这个类中多了几个成员变量，我就说几个看起来不那么清楚的成员变量。</p>
<p><code>_isCNumber</code> 这里变量表示是不是一个C语言的类型，比如<code>int</code>这样的。 </p>
<p><code>_genericCls</code>这个变量在精简版里没用到，我只是放在这里，YYModel 可以给容器型的属性转换，具体可以看YY大神的文档。</p>
<p><code>_isKVCCompatible</code> 能不能支持 KVC</p>
<p><code>_mappedToKey</code> 要映射的 key，把 JSON 转成 Model 的时会根据这个 key 把相同字段的 JSON 值赋值给这个 Property。</p>
<p>为了判断 NS 的类型和是否是 C 类型，在 <code>.m</code> 里有两个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#define force_inline __inline__ __attribute__((always_inline))</span><br><span class="line"></span><br><span class="line">static force_inline CPEncodingNSType CPClassGetNSType(Class cls) &#123;</span><br><span class="line">    if (!cls) return CPEncodingTypeNSUnknown;</span><br><span class="line">    if ([cls isSubclassOfClass:[NSMutableString class]]) return CPEncodingTypeNSMutableString;</span><br><span class="line">    if ([cls isSubclassOfClass:[NSString class]]) return CPEncodingTypeNSString;</span><br><span class="line">    if ([cls isSubclassOfClass:[NSDecimalNumber class]]) return CPEncodingTypeNSDecimalNumber;</span><br><span class="line">    if ([cls isSubclassOfClass:[NSNumber class]]) return CPEncodingTypeNSNumber;</span><br><span class="line">    if ([cls isSubclassOfClass:[NSValue class]]) return CPEncodingTypeNSValue;</span><br><span class="line">    if ([cls isSubclassOfClass:[NSMutableData class]]) return CPEncodingTypeNSMutableData;</span><br><span class="line">    if ([cls isSubclassOfClass:[NSData class]]) return CPEncodingTypeNSData;</span><br><span class="line">    if ([cls isSubclassOfClass:[NSDate class]]) return CPEncodingTypeNSDate;</span><br><span class="line">    if ([cls isSubclassOfClass:[NSURL class]]) return CPEncodingTypeNSURL;</span><br><span class="line">    if ([cls isSubclassOfClass:[NSMutableArray class]]) return CPEncodingTypeNSMutableArray;</span><br><span class="line">    if ([cls isSubclassOfClass:[NSArray class]]) return CPEncodingTypeNSArray;</span><br><span class="line">    if ([cls isSubclassOfClass:[NSMutableDictionary class]]) return CPEncodingTypeNSMutableDictionary;</span><br><span class="line">    if ([cls isSubclassOfClass:[NSDictionary class]]) return CPEncodingTypeNSDictionary;</span><br><span class="line">    if ([cls isSubclassOfClass:[NSMutableSet class]]) return CPEncodingTypeNSMutableSet;</span><br><span class="line">    if ([cls isSubclassOfClass:[NSSet class]]) return CPEncodingTypeNSSet;</span><br><span class="line">    return CPEncodingTypeNSUnknown;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static force_inline BOOL CPEncodingTypeIsCNumber(CPEncodingType type) &#123;</span><br><span class="line">    switch (type &amp; CPEncodingTypeMask) &#123;</span><br><span class="line">        case CPEncodingTypeBool:</span><br><span class="line">        case CPEncodingTypeInt8:</span><br><span class="line">        case CPEncodingTypeUInt8:</span><br><span class="line">        case CPEncodingTypeInt16:</span><br><span class="line">        case CPEncodingTypeUInt16:</span><br><span class="line">        case CPEncodingTypeInt32:</span><br><span class="line">        case CPEncodingTypeUInt32:</span><br><span class="line">        case CPEncodingTypeInt64:</span><br><span class="line">        case CPEncodingTypeUInt64:</span><br><span class="line">        case CPEncodingTypeFloat:</span><br><span class="line">        case CPEncodingTypeDouble:</span><br><span class="line">        case CPEncodingTypeLongDouble: return YES;</span><br><span class="line">        default: return NO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个函数不用多说了，很简单，要说明一下宏定义 <code>force_inline</code> 所有标记了 <code>force_inline</code> 的函数叫做内联函数，在调用的时候都不是一般的调用，而是在编译的时候就已经整个丢进了调用这个函数的方法或函数里去了，这和平时定义一个宏一样，你在哪里使用到了这个宏，那么在编译的时候编译器就会把你使用这个宏的地方替换成宏的值。为什么要这么做呢？因为效率，调用一个函数也是有开销的，调用一个函数有压栈弹栈等操作。如果你的函数很小，你这么一弄就免去了这些操作。</p>
<p>然后看一下<code>CPModelPropertyMeta</code>的初始化方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)modelWithClassInfo:(CPClassInfo *)clsInfo propretyInfo:(CPClassPropertyInfo *)propertyInfo generic:(Class)generic&#123;</span><br><span class="line">    CPModelPropertyMeta *meta = [self new];</span><br><span class="line">    meta-&gt;_name = propertyInfo.name;</span><br><span class="line">    meta-&gt;_type = propertyInfo.type;</span><br><span class="line">    meta-&gt;_info = propertyInfo;</span><br><span class="line">    meta-&gt;_genericCls = generic;</span><br><span class="line">    </span><br><span class="line">    if ((meta-&gt;_type &amp; CPEncodingTypeMask) == CPEncodingTypeObject) &#123;</span><br><span class="line">        meta-&gt;_nsType = CPClassGetNSType(propertyInfo.cls);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        meta-&gt;_isCNumber = CPEncodingTypeIsCNumber(meta-&gt;_type);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    meta-&gt;_cls = propertyInfo.cls;</span><br><span class="line">    </span><br><span class="line">    if (propertyInfo.getter) &#123;</span><br><span class="line">        if ([clsInfo.cls instancesRespondToSelector:propertyInfo.getter]) &#123;</span><br><span class="line">            meta-&gt;_getter = propertyInfo.getter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (propertyInfo.setter) &#123;</span><br><span class="line">        if ([clsInfo.cls instancesRespondToSelector:propertyInfo.setter]) &#123;</span><br><span class="line">            meta-&gt;_setter = propertyInfo.setter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (meta-&gt;_setter &amp;&amp; meta-&gt;_getter) &#123;</span><br><span class="line">        switch (meta-&gt;_type &amp; CPEncodingTypeMask) &#123;</span><br><span class="line">            case CPEncodingTypeBool:</span><br><span class="line">            case CPEncodingTypeInt8:</span><br><span class="line">            case CPEncodingTypeUInt8:</span><br><span class="line">            case CPEncodingTypeInt16:</span><br><span class="line">            case CPEncodingTypeUInt16:</span><br><span class="line">            case CPEncodingTypeInt32:</span><br><span class="line">            case CPEncodingTypeUInt32:</span><br><span class="line">            case CPEncodingTypeInt64:</span><br><span class="line">            case CPEncodingTypeUInt64:</span><br><span class="line">            case CPEncodingTypeFloat:</span><br><span class="line">            case CPEncodingTypeDouble:</span><br><span class="line">            case CPEncodingTypeObject:</span><br><span class="line">            case CPEncodingTypeClass:</span><br><span class="line">            case CPEncodingTypeBlock:</span><br><span class="line">            case CPEncodingTypeStruct:</span><br><span class="line">            case CPEncodingTypeUnion: &#123;</span><br><span class="line">                meta-&gt;_isKVCCompatible = YES;</span><br><span class="line">            &#125; break;</span><br><span class="line">            default: break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return meta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断一下是否是 object 的类型，然后拿到具体的 NS 类型，或者判断一下是不是 C 类型，然后拿到 <code>getter</code> <code>setter</code> 最后判断一下能不能 KVC。</p>
<h4 id="CPModelPropertyMeta-1"><a href="#CPModelPropertyMeta-1" class="headerlink" title="CPModelPropertyMeta"></a>CPModelPropertyMeta</h4><p>这个类主要是生成一个映射表，这个映射表就是 <code>_mapper</code> 这个变量，这个类也需要被缓存起来，套路和上面讲到的缓存套路一样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)metaWithClass:(Class)cls &#123;</span><br><span class="line">    if (!cls) return nil;</span><br><span class="line">    static CFMutableDictionaryRef cache;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    static dispatch_semaphore_t lock;</span><br><span class="line">    </span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        cache = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        lock = dispatch_semaphore_create(1);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span><br><span class="line">    CPModelMeta *meta = CFDictionaryGetValue(cache, (__bridge const void *)(cls));</span><br><span class="line">    dispatch_semaphore_signal(lock);</span><br><span class="line">    </span><br><span class="line">    if (!meta || meta-&gt;_clsInfo.needUpdate) &#123;</span><br><span class="line">        meta = [[CPModelMeta alloc] initWithClass:cls];</span><br><span class="line">        if (meta) &#123;</span><br><span class="line">            dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span><br><span class="line">            CFDictionarySetValue(cache, (__bridge const void *)(cls), (__bridge const void *)(meta));</span><br><span class="line">            dispatch_semaphore_signal(lock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return meta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缓存没命中就调用 <code>initWithClass:</code> 来进行初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithClass:(Class)cls&#123;</span><br><span class="line">    if (!cls) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        CPClassInfo *clsInfo = [CPClassInfo classInfoWithClass:cls];</span><br><span class="line">        NSMutableDictionary *allPropertyMetas = [NSMutableDictionary new];</span><br><span class="line">        CPClassInfo *curClsInfo = clsInfo;</span><br><span class="line">        //连同当前的类和其父类的属性一起放入allPropertyMetas数组，(NSObject和NSProxy是没有父类的）</span><br><span class="line">        while (curClsInfo &amp;&amp; curClsInfo.superClass != nil) &#123;</span><br><span class="line">            for (CPClassPropertyInfo *propertyInfo in curClsInfo.propertyInfos.allValues) &#123;</span><br><span class="line">                if (!propertyInfo.name)continue;</span><br><span class="line">                CPModelPropertyMeta *meta = [CPModelPropertyMeta modelWithClassInfo:clsInfo propretyInfo:propertyInfo generic:nil];</span><br><span class="line">                if (!meta || !meta-&gt;_name)continue;</span><br><span class="line">                if (!meta-&gt;_setter || !meta-&gt;_getter)continue;</span><br><span class="line">                if (allPropertyMetas[meta-&gt;_name])continue;</span><br><span class="line">                allPropertyMetas[meta-&gt;_name] = meta;</span><br><span class="line">            &#125;</span><br><span class="line">            curClsInfo = clsInfo.superClassInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (allPropertyMetas.count) &#123;</span><br><span class="line">            _allPropertyMetas = allPropertyMetas.allValues.copy;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        NSMutableDictionary *mapper = [NSMutableDictionary new];</span><br><span class="line">        </span><br><span class="line">        [allPropertyMetas enumerateKeysAndObjectsUsingBlock:^(NSString *  _Nonnull name, CPModelPropertyMeta *  _Nonnull meta, BOOL * _Nonnull stop) &#123;</span><br><span class="line">            meta-&gt;_mappedToKey = name;</span><br><span class="line">            mapper[name] = meta;</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        if (mapper.count) _mapper = mapper;</span><br><span class="line">        _clsInfo = clsInfo;</span><br><span class="line">        _keyMappedCount = _allPropertyMetas.count;</span><br><span class="line">        _nsType = CPClassGetNSType(cls);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把 <code>CPClassInfo</code> 里所有的 <code>propertyInfo</code> 遍历出来，实例化成一个 <code>CPModelPropertyMeta</code> ，还顺便把 <code>CPClassInfo</code> 父类的所有 <code>propertyInfo</code> 也拿出来，这样一来，你的 Model 即便有一个父类也能把父类的 Property 赋值。</p>
<p>然后生成一个映射表，就基本完成了初始化工作了，这张映射表是关键，等一下所有的 JSON 的转换都依赖这一张表。</p>
<h2 id="从-JSON-到-Model-的转换"><a href="#从-JSON-到-Model-的转换" class="headerlink" title="从 JSON 到 Model 的转换"></a>从 JSON 到 Model 的转换</h2><p>现在进入正餐环节，我们刚才已经把所有的准备工作完成了，现在要开始正式的完成从 JSON 到 Model 的转换了。</p>
<p>首先，先建一个 Category，取名 CPModel，因为我们只完成整个 YYMode 的一个主要功能，所以我们只给出一个接口就行了，所以头文件很简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface NSObject (CPModel)</span><br><span class="line"></span><br><span class="line">+ (instancetype)modelWithJSON:(id)json;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>使用者只需要调用 <code>+ modelWithJSON:</code> 即可完成转换的操作。</p>
<p>现在看看这个方法要怎么实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)modelWithJSON:(id)json &#123;</span><br><span class="line">    NSDictionary *dic = [self _cp_dictionaryWithJSON:json];</span><br><span class="line">    if (!dic || dic == (id)kCFNull) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if (![dic isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Class cls = [self class];</span><br><span class="line">    </span><br><span class="line">	NSObject *one = [cls new];</span><br><span class="line">    if ([one modelSetWithDictionary:dic]) &#123;</span><br><span class="line">        return one;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先先把 JSON 转换成 NSDictionary ，然后得到该 Model 的 Class 去实例化这个 Model，接着调用一个叫做<code>- modelSetWithDictionary:</code> 的方法。</p>
<p>把 JSON 转换成 NSDictionary 的方法很简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (NSDictionary *)_cp_dictionaryWithJSON:(id)json&#123;</span><br><span class="line">    if (!json || json == (id)kCFNull) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    NSDictionary *dic = nil;</span><br><span class="line">    NSData *data = nil;</span><br><span class="line">    if ([json isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">        dic = json;</span><br><span class="line">    &#125;else if ([json isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">        data = [(NSString *)json dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">    &#125;else if ([json isKindOfClass:[NSData class]]) &#123;</span><br><span class="line">        data = json;</span><br><span class="line">    &#125;</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        dic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableLeaves error:nil];</span><br><span class="line">        if (![dic isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">            dic = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后看一下 <code>- modelSetWithDictionary:</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)modelSetWithDictionary:(NSDictionary *)dic&#123;</span><br><span class="line">    if (!dic || dic == (id)kCFNull) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    if (![dic isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    CPModelMeta *meta = [CPModelMeta metaWithClass:object_getClass(self)]; //①</span><br><span class="line">    if (meta-&gt;_keyMappedCount == 0) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ModelSetContext context = &#123;0&#125;;</span><br><span class="line">    context.modelMeta = (__bridge void *)(meta);</span><br><span class="line">    context.model = (__bridge void *)(self);</span><br><span class="line">    context.dictionary = (__bridge void *)(dic);</span><br><span class="line">    </span><br><span class="line">    if (meta-&gt;_keyMappedCount &gt;= dic.count) &#123;</span><br><span class="line">        CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &amp;context);</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个结构体，这个结构体用来存储 <code>model</code>（因为是给这个Model 里的 Property 赋值）、<code>modelMeta</code>（刚才也看到了，这里存放了映射表）、<code>dictionary</code>（这是由 JSON 转换过来的），这个结构体的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    void *modelMeta;</span><br><span class="line">    void *model;</span><br><span class="line">    void *dictionary;</span><br><span class="line">&#125; ModelSetContext;</span><br></pre></td></tr></table></figure>
<p>然后在<code>- modelSetWithDictionary:</code>有这么一行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &amp;context);</span><br></pre></td></tr></table></figure>
<p>这个代码的作用是，把一对 <code>Key - Value</code> 拿出来，然后调用你传进去的函数<code>ModelSetWithDictionaryFunction()</code>，你有多少对<code>Key - Value</code>，它就会调用多少次这个函数，相当于便利所有的<code>Key - Value</code>，为什么要这样做，而不用一个循环呢？在YY大神的博客里有这么一段</p>
<blockquote>
<p>遍历容器类时，选择更高效的方法</p>
<p>相对于 Foundation 的方法来说，CoreFoundation 的方法有更高的性能，用 CFArrayApplyFunction() 和 CFDictionaryApplyFunction() 方法来遍历容器类能带来不少性能提升，但代码写起来会非常麻烦。</p>
</blockquote>
<p>然后我们来看一下<code>ModelSetWithDictionaryFunction()</code>的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void ModelSetWithDictionaryFunction(const void *key, const void *value, void *context) &#123;</span><br><span class="line">    ModelSetContext *ctx = context;</span><br><span class="line">    __unsafe_unretained CPModelMeta *modelMeta = (__bridge CPModelMeta *)(ctx-&gt;modelMeta);</span><br><span class="line">    __unsafe_unretained CPModelPropertyMeta *propertyMeta = [modelMeta-&gt;_mapper objectForKey:(__bridge id)(key)];</span><br><span class="line">    __unsafe_unretained id model = (__bridge id)(ctx-&gt;model);</span><br><span class="line">    if (propertyMeta-&gt;_setter) &#123;</span><br><span class="line">        ModelSetValueForProperty(model, (__bridge __unsafe_unretained id)value, propertyMeta);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么在变量前都加了<code>__unsafe_unretained</code>，YY大神也说了</p>
<blockquote>
<p>避免多余的内存管理方法</p>
<p>在 ARC 条件下，默认声明的对象是 <strong>strong 类型的，赋值时有可能会产生 retain/release 调用，如果一个变量在其生命周期内不会被释放，则使用 </strong>unsafe_unretained 会节省很大的开销。</p>
<p>访问具有 <strong>weak 属性的变量时，实际上会调用 objc_loadWeak() 和 objc_storeWeak() 来完成，这也会带来很大的开销，所以要避免使用 </strong>weak 属性。</p>
</blockquote>
<p>继续，根据 key（这个 key 就是 JSON 里的字段，应该和你 Model 定义的 Property 名相同，否则就匹配不了，在 YYMode 中有一个自定义映射表的支持，我把它去掉了，有兴趣的可以下载 YYMode 的源码看一下） 取出映射表里的 <code>propertyMeta</code>。现在我们有了要转换的 model 对象，和一个和 JSON 里字段对应的 <code>propertyMeta</code> 对象，已经该 JSON 字段的值，现在要赋值的条件全部具备了，我们只需要调用<code>propertyMeta</code>中的<code>setter</code>方法，然后把值传进去就完成了，这部分的工作由 <code>ModelSetValueForProperty()</code>函数完成，这个函数里有大量的类型判断，为了简单起见，我就判断了<code>NSString</code> <code>NSNumber</code> 和普通C语言类型，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">static void ModelSetValueForProperty(__unsafe_unretained id model, __unsafe_unretained id value, __unsafe_unretained CPModelPropertyMeta *meta) &#123;</span><br><span class="line">    if (meta-&gt;_isCNumber) &#123;</span><br><span class="line">        NSNumber *num = CPNSNumberCreateFromID(value);</span><br><span class="line">        ModelSetNumberToProperty(model, num, meta);</span><br><span class="line">        if (num) [num class];</span><br><span class="line">    &#125; else if (meta-&gt;_nsType) &#123;</span><br><span class="line">        if (value == (id)kCFNull) &#123;</span><br><span class="line">            ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model, meta-&gt;_setter, (id)nil);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            switch (meta-&gt;_nsType) &#123;</span><br><span class="line">                case CPEncodingTypeNSString:</span><br><span class="line">                case CPEncodingTypeNSMutableString: &#123;</span><br><span class="line">                    if ([value isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">                        if (meta-&gt;_nsType == CPEncodingTypeNSString) &#123;</span><br><span class="line">                            ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model, meta-&gt;_setter, value);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model, meta-&gt;_setter, ((NSString *)value).mutableCopy);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else if ([value isKindOfClass:[NSNumber class]]) &#123;</span><br><span class="line">                        ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model,</span><br><span class="line">                                                                       meta-&gt;_setter,</span><br><span class="line">                                                                       (meta-&gt;_nsType == CPEncodingTypeNSString) ?</span><br><span class="line">                                                                       ((NSNumber *)value).stringValue :</span><br><span class="line">                                                                       ((NSNumber *)value).stringValue.mutableCopy);</span><br><span class="line">                    &#125; else if ([value isKindOfClass:[NSData class]]) &#123;</span><br><span class="line">                        NSMutableString *string = [[NSMutableString alloc] initWithData:value encoding:NSUTF8StringEncoding];</span><br><span class="line">                        ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model, meta-&gt;_setter, string);</span><br><span class="line">                    &#125; else if ([value isKindOfClass:[NSURL class]]) &#123;</span><br><span class="line">                        ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model,</span><br><span class="line">                                                                       meta-&gt;_setter,</span><br><span class="line">                                                                       (meta-&gt;_nsType == CPEncodingTypeNSString) ?</span><br><span class="line">                                                                       ((NSURL *)value).absoluteString :</span><br><span class="line">                                                                       ((NSURL *)value).absoluteString.mutableCopy);</span><br><span class="line">                    &#125; else if ([value isKindOfClass:[NSAttributedString class]]) &#123;</span><br><span class="line">                        ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model,</span><br><span class="line">                                                                       meta-&gt;_setter,</span><br><span class="line">                                                                       (meta-&gt;_nsType == CPEncodingTypeNSString) ?</span><br><span class="line">                                                                       ((NSAttributedString *)value).string :</span><br><span class="line">                                                                       ((NSAttributedString *)value).string.mutableCopy);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; break;</span><br><span class="line">                case CPEncodingTypeNSNumber:&#123;</span><br><span class="line">                    if ([value isKindOfClass:[NSNumber class]]) &#123;</span><br><span class="line">                        if (meta-&gt;_nsType == CPEncodingTypeNSNumber) &#123;</span><br><span class="line">                            ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model,meta-&gt;_setter,value);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; break;</span><br><span class="line">                    </span><br><span class="line">                default: break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 <code>objc_msgSend()</code> 我们随便拿一行例子来举例，比如这个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model, meta-&gt;_setter, value);</span><br></pre></td></tr></table></figure>
<p>这是一个可以调用者决定返回值和参数的函数，一般的函数是做不到的，默认情况下这个函数是长这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(id, SEL)</span><br></pre></td></tr></table></figure>
<p><code>id</code> 是指调用某一个方法的对象，在这里这个对象就是你的 Model</p>
<p><code>SEL</code> 是指你这个对象要调用的方法是什么，在这里这个方法就是 <code>setter</code>方法</p>
<p>然而，<code>setter</code> 方法是有参数的，这个参数怎么传进去？这就需要强制类型转换了，我们把这个函数强制转换成这个模样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((void (*)(id, SEL, id))(void *) objc_msgSend)</span><br></pre></td></tr></table></figure>
<p>这样代表这个函数是一个没有返回值，并且有3个参数的函数，分别是 <code>id</code> <code>SEL</code> <code>id</code>，前面两个参数之前讲过了，第三个参数就是你要调用的这个 <code>setter</code> 方法需要的参数，所以经过强制类型转换之后的变异版就成了一开始的那种样子。</p>
<p>其余的都没有什么好讲的了，都很简单，都是一些烦人的类型判断，只要仔细一点一行行看就能看懂了。</p>
<p>全部搞定以后，和原版的 YYModel 一样，你可以这么来测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPTestModel *model = [CPTestModel modelWithJSON:@&quot;&#123;\&quot;name\&quot;: \&quot;Harry Potter\&quot;,\&quot;index\&quot;: 512,\&quot;number\&quot;: 10,\&quot;num\&quot;: 100&#125;&quot;];</span><br></pre></td></tr></table></figure>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>如果你自己亲自动手写完了这个精简版的 YYMode ，你再去看完整版的会容易很多，我写的这篇文章是把我从读 YYModel 源码中学到的一些有用的东西分享给大家，如有什么写错的地方，欢迎指正。</p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><p>点击<a href="https://github.com/J0HDev/CPModel" target="_blank" rel="external">这里</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读完这篇文章你可以自己写一个 YYModel 这样的神器，这篇文章类似一个源码解析，但不同的是，它不光光是解析，更是实战，因为我觉得学习一个东西必须要自己写一遍才算是真的学了一遍，否则即便是读完了源码印象还是不会太深刻，so，开始吧。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：为了简单起见
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>__inline__ __attribute__((always_inline)) 的意思</title>
    <link href="http://yoursite.com/2016/08/12/inline-attribute-always-inline-%E7%9A%84%E6%84%8F%E6%80%9D/"/>
    <id>http://yoursite.com/2016/08/12/inline-attribute-always-inline-的意思/</id>
    <published>2016-08-12T07:43:25.000Z</published>
    <updated>2016-08-12T07:52:20.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="gcc" scheme="http://yoursite.com/tags/gcc/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言学习笔记3</title>
    <link href="http://yoursite.com/2016/07/24/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/"/>
    <id>http://yoursite.com/2016/07/24/汇编语言学习笔记3/</id>
    <published>2016-07-24T06:18:03.000Z</published>
    <updated>2016-07-25T08:00:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前写的汇编全都是通过DEBUG这个程序来完成的，对于一些几行代码的程序用它完全没问题，但是要写规模稍微大一些的就不能这样了，而是采用传统的方式，用文本编辑器写汇编代码，用汇编编译器和连接器来完成编译的工作，最后运行。</p>
<p>由于书本上的编译方式在 Windows10 上不太好用，所以我自己找了一个其他的方法，基本和书上差不多，也是使用 MASM 来编译。顺便说一下 MASM 是微软公司的汇编器。</p>
<p>首先在 <a href="masm32.com">这个网站</a> 下载 MASM 的 SDK，里面包含了编译器、连接器和一个文本编辑器，但它貌似只能编译32位的程序，这个无所谓了。然后一路点击安装，傻瓜式的安装器。（PS：加入是 Windows10 的操作系统，它默认会有一个杀毒软件，会自动把一些必要文件删除，导致安装失败，所以安装的时候把那个该死的杀毒软件关掉）</p>
<p>在编辑器里其实有编译和连接甚至有直接运行的按钮，点击即可，但是我点了编译却找不到编译后的文件，所以我还是通过命令行的方式手动编译了我的测试代码。</p>
<h2 id="编译方法"><a href="#编译方法" class="headerlink" title="编译方法"></a>编译方法</h2><p>如果希望方便一点，可以在系统的环境变量里配置一下，编译器和连接器都在安装目录下 <code>bin\</code> 文件夹下。</p>
<p>具体的配置流程：</p>
<ul>
<li>右击此电脑 —— 属性 —— 高级系统设置 —— 环境变量</li>
<li>在系统变量那一栏找到 Path 点击编辑，Windows10 和之前的都不一样了，可以点右边一排按钮的新建，在最底下把路径加进去(D:\masm32\bin)</li>
</ul>
<p>这样一来，可以直接打开编译器程序了。</p>
<p>进入汇编源程序的目录，比如 D:\assembly</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; cd D:\assembly</span><br><span class="line">&gt; ml \c first.asm</span><br></pre></td></tr></table></figure>
<p>然后就会在目录下生成一个.obj文件，然后用链接器链接这个文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; link16 first.obj</span><br></pre></td></tr></table></figure>
<p>然后它会让你输入 Run File、List File、Libraries、Definitions File 可以直接按回车使用默认就行了。</p>
<p>然后目录下就会出现 first.exe 这个可执行文件了。</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>这是一个 32 位编译的程序，直接在 64 位的 Windows10 （我的系统）上是跑不起来的，所以可以继续用到 DosBox 这个神器，在使用的时候要先把你刚才编译文件的目录挂载为一个盘，我把它挂载为 D:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; mount d d:\</span><br><span class="line">&gt; d:</span><br></pre></td></tr></table></figure>
<p>这样就可以进入刚才编译好可执行程序的那个目录下运行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; cd ASSEMBLY</span><br><span class="line">&gt; first</span><br></pre></td></tr></table></figure>
<p>大功告成~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写的汇编全都是通过DEBUG这个程序来完成的，对于一些几行代码的程序用它完全没问题，但是要写规模稍微大一些的就不能这样了，而是采用传统的方式，用文本编辑器写汇编代码，用汇编编译器和连接器来完成编译的工作，最后运行。&lt;/p&gt;
&lt;p&gt;由于书本上的编译方式在 Windows1
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言学习笔记（2）</title>
    <link href="http://yoursite.com/2016/07/23/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <id>http://yoursite.com/2016/07/23/汇编语言学习笔记2/</id>
    <published>2016-07-23T03:32:58.000Z</published>
    <updated>2016-07-24T06:35:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>第三章主要讲了四大块内容</p>
<ul>
<li>把数据从寄存器写到内存或者从内存写到寄存器</li>
<li>一个字该如何传送</li>
<li>数据段的概念</li>
<li>栈</li>
</ul>
<p>CPU如果要读写一段内存，那么必须要给出这段内存的地址，8086CPU的地址总线有20位，但是它本身却是一个16位的CPU，所以不可能一口气给出一个20位的地址出来，所以必须通过两个16位的地址来计算出一个20位的地址来输送到20位的地址总线，计算的方式是 <em>段地址 x 16 + 偏移地址</em> 所以一般来说，你要访问一块内存，需要给一个叫 DS 的寄存器赋值，这个寄存器里的值是你要访问的这段内存的段地址，比如要把内存地址为 10000H 的内容拿出来，保存到寄存器 AL (AX 寄存器的低8位寄存器) 里，就可以这么写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov bx, 1000H ;段地址</span><br><span class="line">mov ds, bx</span><br><span class="line">mov al, [0] ;偏移量为0，计算出内存地址为 10000H</span><br></pre></td></tr></table></figure>
<p>当执行到 <code>mov al, [0]</code> 这行代码的时候，CPU就知道这是在取某块内存的值，CPU就会跑到 DS 寄存器中去拿段地址，然后根据这个偏移量合成真实的物理地址，取值，赋值。</p>
<p>当然也可以把寄存器里的值丢到内存中去，如果是这样的话，可以这么写 <code>mov [0], al</code></p>
<h2 id="关于字"><a href="#关于字" class="headerlink" title="关于字"></a>关于字</h2><p>一个字就是两个字节，也就是16个位，像 AX 这样的寄存器，本身就是16位的，本身就可以保存一个字的大小，为了兼容之前的8位CPU，所以才会有 AH AL 这样的高位低位寄存器。在内存中，一个字就占用两个内存单元，因为一个内存单元只能保存一个字节，两个字节才能当做一个字，所以会占两个单元。在内存中保存时，会有高低位之分，高位的部分会存在高地址单元，低位的部分会存在低地址单元，如果把一段内存看做是一个从左往右的方格的话，左边是低地址单元，右边这个是高地址单元。如果看成从上往下的话，上面这个单元就是低地址单元，下面才是高地址单元。</p>
<p>比如,把十进制的 20000(4e20) 放进内存的话，在内存中就会这样存放：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|-------------------------|</span><br><span class="line">|       0    |    1       |</span><br><span class="line">|------------|------------|</span><br><span class="line">|       20   |    4e      |</span><br><span class="line">|-------------------------|</span><br></pre></td></tr></table></figure>
<p>内存单元0是低地址单元，所以存放低位的20，内存单元1是高地址单元锁存存放高位的4e。</p>
<p>将地址为 N 的字单元简称为 N 地址单元，比如刚才这个单元，由 0、1两个内存单元组成，这个字单元的起始地址是0，就可以叫做 0地址单元。</p>
<h2 id="如何存取一个字"><a href="#如何存取一个字" class="headerlink" title="如何存取一个字"></a>如何存取一个字</h2><p>其实很简单，那刚才的代码为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov bx, 1000H</span><br><span class="line">mov ds, bx</span><br><span class="line">mov al, [0]</span><br></pre></td></tr></table></figure>
<p>最后一行 <code>mov al, [0]</code> 可以看到这是 AX 寄存器的低位寄存器，只要把 AL 换成 AX CPU 就知道你要传输的是一个字的数据了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov bx, 1000H</span><br><span class="line">mov ds, bx</span><br><span class="line">mov ax, [0]</span><br></pre></td></tr></table></figure>
<h2 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h2><p>我们可以把一组内存单元定义成一个段来使用，这个段的地址必须是连续的，不然不可能是一个段，而且它的起始地址肯定是 16 的倍数，由于一个段的偏移量最小为0，最大为 ffff （16位），所以它的最大长度只能是 64KB。</p>
<p>数据段只是在编程时候的一种安排，CPU并不知道这一点，其实在使用数据段的时候就和刚才访问内存一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 123BH</span><br><span class="line">mov ds, ax</span><br><span class="line">moc ax, 0</span><br><span class="line">add ax, [0]</span><br><span class="line">add ax, [2]</span><br><span class="line">add ax, [4]</span><br></pre></td></tr></table></figure>
<p>上面的代码是把 123b0 ~ 123b4 这段内存中的值累加到寄存器 AX 中。需要注意的是，不能直接把值赋给 DS 寄存器，就像这样 <code>mov ds, 123BH</code>，这样是非法的，只能用一个寄存器来做中转。</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈本身就是一个先进后出的数据结构，在学数据结构的时候就已经了解它了。CPU也提供这种机制，CPU提供了 <code>PUSH</code> <code>POP</code> 这两个指令来把一段内存当做栈使用，CPU 是怎么知道你执行 <code>PUSH</code> <code>POP</code> 是把哪一段内存当做栈呢？在使用栈的时候，肯定需要一个指向栈顶的指针，这个指针在哪里？在 CPU 内部有一个寄存器 SS 和一个偏移寄存器 SP，这俩寄存器合成的物理地址指向栈顶。通常在 SS 寄存器中保存你要当做栈的那段地址的段地址，SP 中则保存偏移地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 1000H</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 0010H ; *</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push ds</span><br></pre></td></tr></table></figure>
<p>这段代码可以把 AX BX DS 中的值分别压栈到 段为1000H 的内存中。注释中有 * 的这行代码有必要解释下，一般情况下，一个空栈的栈顶指针指向栈内最后一个单元的下面一个，实际上栈的入栈和出栈都是以字为单位的，所以每一次 <code>PUSH</code> <code>POP</code> 的时候 SP 实际上是 <code>SP = SP + 2</code> OR <code>SP = SP - 2</code>。假设我们把 10000 ~ 1000F 这段内存当栈来使用，当这个栈只剩一个元素的时候，SP 指向的是 1000E 这里，那么要把栈清空，就必须把当前这个元素出栈，那么执行 <code>POP</code> 之后， <code>SP = SP + 2</code> 1000E + 2 等于 10010，所以当栈为空栈的时候，一定不是指向最后一个单元，而是指向最后一个单元下面的一个单元。</p>
<p>要注意的是，8086CPU 不会检查栈顶超界，所以需要我们自己注意。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第三章主要讲了四大块内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把数据从寄存器写到内存或者从内存写到寄存器&lt;/li&gt;
&lt;li&gt;一个字该如何传送&lt;/li&gt;
&lt;li&gt;数据段的概念&lt;/li&gt;
&lt;li&gt;栈&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CPU如果要读写一段内存，那么必须要给出这段内存的地址，80
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>算法笔记（五）</title>
    <link href="http://yoursite.com/2016/07/14/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC%E4%BA%94%E5%A4%A9%EF%BC%89/"/>
    <id>http://yoursite.com/2016/07/14/每日一算法（第五天）/</id>
    <published>2016-07-14T10:22:26.000Z</published>
    <updated>2016-07-20T02:25:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种先进后出的数据结构，很简单就不细说了。今天是用栈来实现判断是否是回文串的算法。思路是这样的，把字符串的一半压栈，然后出栈一个字符和另一半的第一个字符对比，如果一样，就把栈指针减一，否则跳出循环。如果最终栈指针为0，则它是回文串，否则不是。</p>
<p>Swift 版实现：</p>
<p>我自己写了一个精简修改版的栈，这里为了让栈指针在比对后减一，所以在出栈的方法中没有让它减一。</p>
<p>首先是栈的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct Stack &lt;T&gt; &#123;</span><br><span class="line">    var data = [T]()</span><br><span class="line">    var top = 0</span><br><span class="line">    mutating func push(value value: T)&#123;</span><br><span class="line">        data.append(value)</span><br><span class="line">        top += 1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func pop() -&gt; T &#123;</span><br><span class="line">        return data.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现了一个支持泛型的栈，Just for fun ^_^</p>
<p>Swift 的 <code>String</code> 类型有一个坑爹的地方，就是不能通过下标来获取某一个字符，还有，它没有 <code>length</code> 属性，所以我先写了一个扩展来让它具备这样的功能，方便一会写算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">extension String &#123;</span><br><span class="line">    subscript(range: Range&lt;Int&gt;) -&gt; String &#123;</span><br><span class="line">        get&#123;</span><br><span class="line">            let startIndex = self.startIndex.advancedBy(range.startIndex)</span><br><span class="line">            let endIndex = self.startIndex.advancedBy(range.endIndex)</span><br><span class="line">            return self[startIndex..&lt;endIndex]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    subscript(index: Int) -&gt; String &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            let startIndex = self.startIndex.advancedBy(index)</span><br><span class="line">            let endIndex = self.startIndex.advancedBy(index + 1)</span><br><span class="line">            return self[startIndex ..&lt; endIndex]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var length: Int &#123; return (self as NSString).length &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在 <code>String</code> 已经可以实现通过下标的方式来取一个字符串，和通过一段范围来截取一段字符串了。</p>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;abcdef&quot;</span><br><span class="line">str[1] // b</span><br><span class="line">str[1..&lt;3] //bc</span><br><span class="line">str[1...3] //bcd</span><br></pre></td></tr></table></figure>
<p>算法很简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func isPalindromic() &#123;</span><br><span class="line">    let str = &quot;ahaha&quot;</span><br><span class="line">    let mid = str.length / 2 - 1</span><br><span class="line">    var stack = Stack&lt;String&gt;()</span><br><span class="line">    var next = 0</span><br><span class="line">    </span><br><span class="line">    for index in 0...mid &#123;</span><br><span class="line">        stack.push(value: str[index])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (str.length % 2 == 0) &#123;</span><br><span class="line">        next = mid + 1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        next = mid + 2</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for index in next...str.length - 1 &#123;</span><br><span class="line">        if (stack.pop() != str[index]) &#123;</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">        stack.top -= 1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (stack.top == 0) &#123;</span><br><span class="line">        print(&quot;是回文串&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        print(&quot;不是回文串&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h2&gt;&lt;p&gt;栈是一种先进后出的数据结构，很简单就不细说了。今天是用栈来实现判断是否是回文串的算法。思路是这样的，把字符串的一半压栈，然后出栈一个字符和另一半的第
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法笔记（四）</title>
    <link href="http://yoursite.com/2016/07/13/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC%E5%9B%9B%E5%A4%A9%EF%BC%89/"/>
    <id>http://yoursite.com/2016/07/13/每日一算法（第四天）/</id>
    <published>2016-07-13T09:39:02.000Z</published>
    <updated>2016-07-20T02:25:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>今天不纯是算法，还有数据结构。</p>
<p>如果别人问你要一个QQ号，你不想直接给他，你告诉他一个加密的序列（比如: <code>6, 3, 1, 7, 5, 8, 9, 2, 0</code>），然后告诉他将第<code>1</code>个元素删除，把第<code>2</code>个元素移动到序列的末尾，然后把第<code>3</code>个元素删除，把第<code>4</code>个元素移动到序列的末尾，直到遇到最后一个元素，把它也删除，然后把这些删除的元素连在一起就是你要的QQ号。</p>
<p>这样的需求你应该怎么做？按照死办法，就是初始化一个数组，初始化的元素就是上面的那些元素，然后开始删除第一个元素，怎么删？把第一个元素之后的所有元素的下标统统往前减一，那么这么做就非常费时了，如果用队列来做就会快许多。</p>
<p>队列的实现就需要一个<code>head</code>、和一个<code>tail</code>两个变量来表示队列的首元素和末元素的下标，当需要删除一个元素时，只需要把<code>head++</code>即可，对于 <code>tail</code> 元素，要让它等于<code>末元素下标+1</code>，因为我们不想到最后让 <code>head == tail</code> 时队列中还剩下一个元素，我们判断队列为空的时才希望让<code>head == tail</code>。如果需要在末尾追加一个元素就只要让数组<code>tail</code>下标的那块区域添加上要追加的那个元素，然后把<code>tail++</code>，这样不管是删除还是追加的时间复杂度均为O(1)，效率非常高，但是浪费了一些空间，这就叫用空间换时间，上帝是不会让你十全十美的。</p>
<p>Swift 版实现:</p>
<p>首先创建一个结构体来表示一个队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Queue &#123;</span><br><span class="line">    var data: [Int]</span><br><span class="line">    var head: Int</span><br><span class="line">    var tail: Int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是具体的算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func jailbrokenQQ() &#123;</span><br><span class="line">	//为了保证有足够的空间来换来换去这些元素，就预留了100个位置</span><br><span class="line">    var queue = Queue(data: [Int](count: 100, repeatedValue: 0), head: 0, tail: 0)</span><br><span class="line">    var data = [6, 3, 1, 7, 5, 8, 9, 2, 0]</span><br><span class="line">    </span><br><span class="line">    //把加密的QQ号码丢进队列里</span><br><span class="line">    for index in 0...data.count - 1 &#123;</span><br><span class="line">        queue.data[index] = data[index]</span><br><span class="line">        queue.tail += 1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //根据解密的逻辑开始解密</span><br><span class="line">    while queue.head &lt; queue.tail &#123;</span><br><span class="line">        print(queue.data[queue.head])</span><br><span class="line">        queue.head += 1</span><br><span class="line">        queue.data[queue.tail] = queue.data[queue.head]</span><br><span class="line">        queue.tail += 1</span><br><span class="line">        queue.head += 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用合适的数据结构来实现同一个算法，会让效率大大增加。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h2&gt;&lt;p&gt;今天不纯是算法，还有数据结构。&lt;/p&gt;
&lt;p&gt;如果别人问你要一个QQ号，你不想直接给他，你告诉他一个加密的序列（比如: &lt;code&gt;6, 3
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法笔记（三）</title>
    <link href="http://yoursite.com/2016/07/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC%E4%B8%89%E5%A4%A9%EF%BC%89/"/>
    <id>http://yoursite.com/2016/07/12/每日一算法（第三天）/</id>
    <published>2016-07-12T08:40:41.000Z</published>
    <updated>2016-07-20T02:25:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>这是一个比昨天的冒泡排序快一点的排序算法，它的思路是这样的：在一个无序的序列中随便寻找一个基准值，一般选择序列的第一个元素，根据这个基准值，把基准值左边比基准值大的统统移到它的右边，把它的右边比它小的统统移到左边，那么这样一来，基准值的左边都是比它小的，右边呢都是比它大的。这样子的一轮就称他为基准值归位（因为一轮完毕以后基准值肯定是在中间），一轮完毕后基准值就把这一串序列分为了左右两串子序列，对于左右两串子序列，我们还可以继续找基准值，继续让大的移右边，小的移左边，所有基准归位完毕后，这串序列就排序完成了。</p>
<p>至于怎么把小于基准的值移左边，大于基准的值移右边，我们可以采用交换的方法，使用两个指针分别指向序列中第一个元素和最后一个元素，然后让两个指针相向移动，<em>但是必须让尾指针先移动，因为基准是第一个元素</em>，尾指针（指向最后一个元素）遇到比基准<code>小</code>的元素就暂时停止移动，等到头指针遇到了一个比基准<code>大</code>的元素，也暂时停止移动，让两个指针指向的元素互换，然后继续移动，继续和上面说明的操作步骤一样进行，当头尾指针相遇时，就说明一轮已经结束了（第一个序列的基准已经归位），然后继续递归做后续序列基准的归位。</p>
<p>Swift 实现（这个算法比较复杂，所以注释特别多）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">var array = [6,1,2,7,9,3,4,5,10,8]</span><br><span class="line"></span><br><span class="line">func quickSort(left left: Int, right: Int)&#123;</span><br><span class="line">    </span><br><span class="line">    //如果 left 大于 right 说明排序已经完成，递归结束</span><br><span class="line">    if (left &gt; right) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var i = left //指向第一个元素</span><br><span class="line">    var j = right //指向第二个元素</span><br><span class="line">    let temp = array[left] //存放基准数</span><br><span class="line">    var t = 0 //交换时临时存放</span><br><span class="line">    </span><br><span class="line">    //i 不等于 j 说明这两个指针还没有碰头</span><br><span class="line">    while i != j &#123;</span><br><span class="line">        </span><br><span class="line">        //如果基准数右边的数大于基准数，就说明符合要求，不需要交换，所以指针继续往前面移动，i 如果大于 j 说明已经碰头了</span><br><span class="line">        while array[j] &gt;= temp &amp;&amp; i &lt; j  &#123;</span><br><span class="line">            j -= 1</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //如果基准数左边的数小于基准数，就说明符合要求，不需要交换。所以指针继续往后面移动，.....</span><br><span class="line">        while array[i] &lt;= temp &amp;&amp; i &lt; j &#123;</span><br><span class="line">            i += 1</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //前面的搜索都找到了不符合要求（即基准右边小于基准，基准左边大于基准），并且 i 和 j 没有碰头，就开始交换 i 和 j 所指向的两个元素</span><br><span class="line">        if (i &lt; j) &#123;</span><br><span class="line">            t = array[i]</span><br><span class="line">            array[i] = array[j]</span><br><span class="line">            array[j] = t</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //出了大的 while 循环，肯定就代表 i == j，意味着碰头了，那么一轮匹配就结束了</span><br><span class="line">    array[left] = array[i]</span><br><span class="line">    array[i] = temp</span><br><span class="line">    </span><br><span class="line">    //继续把上一个基准分割的两个序列和刚才一样操作，所以就要用递归来搞定</span><br><span class="line">    </span><br><span class="line">    //对于左边的子序列，头指针肯定还是left，也就是第0个元素的位置，尾指针则是刚才基准数那个位置的前面一个位置</span><br><span class="line">    quickSort(left: left, right: i - 1)</span><br><span class="line">    </span><br><span class="line">    //对于右边的子序列，头指针是刚才基准数那个位置的后面一个位置，而尾指针肯定还是right，也就是最后一个元素的位置</span><br><span class="line">    quickSort(left: i + 1, right: right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">quickSort(left: 0, right: array.count - 1)</span><br><span class="line"></span><br><span class="line">print(array)</span><br></pre></td></tr></table></figure>
<p>快速排序的平均时间复杂度为 O(NlogN)，在最差的情况下和冒泡一样达到 O(N^2)，但还是比冒泡好多了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h2&gt;&lt;p&gt;这是一个比昨天的冒泡排序快一点的排序算法，它的思路是这样的：在一个无序的序列中随便寻找一个基准值，一般选择序列的第一个元素，
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法笔记（二）</title>
    <link href="http://yoursite.com/2016/07/11/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%A4%A9%EF%BC%89/"/>
    <id>http://yoursite.com/2016/07/11/每日一算法（第二天）/</id>
    <published>2016-07-11T09:43:12.000Z</published>
    <updated>2016-07-20T02:25:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冒泡算法"><a href="#冒泡算法" class="headerlink" title="冒泡算法"></a>冒泡算法</h2><p>冒泡算法的思路是这样的，如果有 n 个元素，就循环 n-1 遍，每一遍都会比较相邻的两个元素的小大（根据从小到大或从大到小的需求来比较大小）可以根据需求，大的和小的（或小的和大的）调换位置，也是非常简单的算法。</p>
<p>Swift 版实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func bubble()&#123;</span><br><span class="line">    </span><br><span class="line">    var array = [10,3,1,4,4,0,2]</span><br><span class="line">    </span><br><span class="line">    for _ in 1..&lt;array.count &#123;</span><br><span class="line">        for index in 0..&lt;array.count - 1 &#123;</span><br><span class="line">            if(array[index] &gt; array[index + 1]) &#123;</span><br><span class="line">                let t = array[index]</span><br><span class="line">                array[index] = array[index + 1]</span><br><span class="line">                array[index + 1] = t</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    print(array)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个算法的缺点是太慢，时间复杂度为 O(n^2)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;冒泡算法&quot;&gt;&lt;a href=&quot;#冒泡算法&quot; class=&quot;headerlink&quot; title=&quot;冒泡算法&quot;&gt;&lt;/a&gt;冒泡算法&lt;/h2&gt;&lt;p&gt;冒泡算法的思路是这样的，如果有 n 个元素，就循环 n-1 遍，每一遍都会比较相邻的两个元素的小大（根据从小到大或从大到小的
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法笔记（一）</title>
    <link href="http://yoursite.com/2016/07/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%89/"/>
    <id>http://yoursite.com/2016/07/10/每日一算法（第一天）/</id>
    <published>2016-07-10T10:33:04.000Z</published>
    <updated>2016-07-20T02:25:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>这是一个非常简单的排序算法，思路是这样的，比如你有一堆的数需要排序，那么首先必须确认这些数的范围，比如[0,10]，那么你就需要11个变量来保存这些数出现的次数，为什么需要11个变量呢？因为在上述的范围中最大值只能是10，最小值只能是0，那你正好就需要11个变量（一个长度为11的数组）下标依次从<code>a[0] -&gt; a[10]</code>。比方这样一堆数：5 8 3 2 1 1 5 ，在这样一堆数中：5 和 1 出现了两次，其余的数各出现一次。刚才声明的那一个长度为11的数组可以想象成是一个个桶，在这些桶里保存的都是这个桶下标那个数所出现的次数，比如 5 出现了两次，那么在元素<code>a[5] = 2</code>，1也出现了两次 <code>a[1] = 2</code>，8 出现了一次，那么 <code>a[8] = 1</code>，最后把每一个元素不为0的下标输出，即为排序过后的顺序。</p>
<p>Swift 版实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func barrel()&#123;</span><br><span class="line">    </span><br><span class="line">    var input = [10,5,20,3,1,5,2,8] //乱序的数</span><br><span class="line">    var t = 0;</span><br><span class="line">    var a = [Int]() //桶</span><br><span class="line">	</span><br><span class="line">	//桶里每一个元素置0</span><br><span class="line">    for _ in 0...21 &#123;</span><br><span class="line">        a.append(0)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //遍历乱序的元素，元素出现一次就丢进桶里并计数</span><br><span class="line">    for i in 0...input.count - 1 &#123;</span><br><span class="line">        t = input[i]</span><br><span class="line">        a[t] += 1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //输出</span><br><span class="line">    for index in 0...a.count - 1 &#123;</span><br><span class="line">        let count = a[index]</span><br><span class="line">        if count == 0 &#123;continue&#125;</span><br><span class="line">        for _ in 1...count &#123;</span><br><span class="line">            print(index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个算法的缺点在于，如果乱序的元素范围够大，那么你就需要更多的变量（桶）来存放元素出现的顺序，这对空间非常浪费，而且如果要排序的元素是小数，那就更头疼了，但如果范围不大，这个算法的时间复杂度非常快  <code>O(M+N)</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;桶排序&quot;&gt;&lt;a href=&quot;#桶排序&quot; class=&quot;headerlink&quot; title=&quot;桶排序&quot;&gt;&lt;/a&gt;桶排序&lt;/h2&gt;&lt;p&gt;这是一个非常简单的排序算法，思路是这样的，比如你有一堆的数需要排序，那么首先必须确认这些数的范围，比如[0,10]，那么你就需要11
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言学习笔记(1)</title>
    <link href="http://yoursite.com/2016/06/28/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://yoursite.com/2016/06/28/汇编语言学习笔记-1/</id>
    <published>2016-06-28T03:37:35.000Z</published>
    <updated>2016-07-24T06:35:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于书"><a href="#关于书" class="headerlink" title="关于书"></a>关于书</h1><p>为了深入学习计算机底层，开始学习汇编。这是第一篇学习笔记，书是 王爽的《汇编语言》，这本书虽然是国人写的，但是不是一本一板一眼的书，对于很多名词和概念他不会一口气讲完，而是会在每一个知识点中慢慢渗透的讲解，书后面还有习题帮助你理解，我个人认为非常好，非常适合自学五星好评。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>所有的16进制如果一眼能看出来是16进制的，比如 005c 那就不加 H， 如果看不出的 8226 那就加一个H 8226h 或者 8226H，大小写看心情。</p>
<p>以下的文章只是学习笔记，非教程，是以我能看懂温习为主。</p>
<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>一个典型的CPU是由运算器、控制器、寄存器等组成，这些器件靠内部总线来传递数据。</p>
<p>不同的CPU寄存器数量、结构不同，8086有14个寄存器，AX BX CX DX SI DI SP BP IP CS SS DS ES PSW。</p>
<p>其中 AX BX CX DX 是通用寄存器，用来存放一般性的数据。</p>
<p>为了兼容上一代CPU（8位的寄存器，而8086是16位的）上述四个通用寄存器可以分为两个独立使用的8位寄存器来用</p>
<ul>
<li>AX -&gt; AH AL</li>
<li>BX -&gt; BH BL</li>
<li>CX -&gt; CH CL</li>
<li>DX -&gt; DH DL</li>
</ul>
<p>把一个16位的寄存器想象成一个16个格子的格子间，从格子间最右边开始的第一个格子的序号为0，最左边的最后一个格子序号为15。0~7称为 <em>低8位</em> 8~15称为 <em>高8位</em>。</p>
<p>独立的两个8位寄存器（类似 AH AL） 被命名为 某H 的是存储高位的寄存器，某L 的是存储地位的寄存器。</p>
<h1 id="字在寄存器中的存储"><a href="#字在寄存器中的存储" class="headerlink" title="字在寄存器中的存储"></a>字在寄存器中的存储</h1><p>一个字（word）由两个字节组成，这两个字分别为这个字的高位字节和地位字节。</p>
<p>比如十进制数 20000，它的二进制为 0100111000100000, 他就可以保存在一个16位的AX寄存器中，AH保存了它的高8位，AL则保存了他低8位。</p>
<ul>
<li>AH -&gt; 01001110 B = 78 = 4E H</li>
<li>AL -&gt; 00100000 B = 32 = 20 H</li>
</ul>
<p>有趣的是，如果把 AH 和 AL 的16进制值拼起来就等于 4E20 恰好等于 20000 的16进制值，这就是16进制表示的好处。</p>
<h1 id="几条汇编指令"><a href="#几条汇编指令" class="headerlink" title="几条汇编指令"></a>几条汇编指令</h1><ul>
<li><code>mov ax,18</code> 把 18 送入寄存器ax</li>
<li><code>add ax,8</code> 在 AX 寄存器原来的值上加 8</li>
<li><code>mov ax,bx</code> 把 BX 寄存器的值送入AX寄存器</li>
<li><code>add ax,bx</code> AX寄存器原来的值加上BX寄存器的值，结果保存在AX中</li>
</ul>
<p>假设 AX = 8226 H ，BX = 8226 H, 如果执行 <code>add ax,bx</code> 即 8226h + 8226h 的值赋给 AX 寄存器，计算下，它们相加的结果为 1044C，转换成二进制是：<code>10000010000111111</code> 17位，所以装不下，要去掉最高位的1，所以最终保存在寄存器 AX 中的值为 044C。</p>
<p>假设 AX = 00c5 BX = 4026h 执行 <code>add al,93H</code>, 也就是说在 AX 寄存器的低8位即 c5 + 93h = 158h , 但是 AX 的低8位寄存器 AL 只能存8位二进制值也就是2位16进制值，所以必须舍弃最高位的1，于是 AL 保存的值为 58h 所以 AX寄存器的值也就成了 AH的值 和 AL的值 拼在一起的值 0058h。</p>
<p><em>注意事项：当使用 <code>mov</code> 或者 <code>add</code> 等指令时，要注意两个操作对象位数是否一致，比如 ax 不能和 bl 放在一起</em></p>
<h1 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h1><p>CPU 访问内存单元的时候，需要告诉内存要访问的这个单元的地址是多少，CPU是通过地址总线来把物理地址送入内存的。</p>
<p>8086 CPU 是16位的，这个16位代表：</p>
<ul>
<li>运算器一次可以运算16位的数据</li>
<li>寄存器最大的宽度也是16</li>
<li>寄存器和运算器之间的通路也是16</li>
</ul>
<p>综上，在CPU的内部，能够一次性处理、传输和存储的数据只能是16位，那么 CPU 需要通过地址总线把要访问的内存单元的地址输入给内存，然而8086实际上地址总线的宽度是20，也就是说一次可以支持传输20位的数据，换算一下它支持的寻址最大为2的20次方，即1MB左右，这时问题来了，16位的 CPU 和 20位的 地址总线，怎么看都浪费地址总线的宽度了，所以这时CPU就需要来合成一个20位的地址来输出。</p>
<h1 id="合成物理地址"><a href="#合成物理地址" class="headerlink" title="合成物理地址"></a>合成物理地址</h1><p>由于16位的CPU一次性写不下20位的数据，于是就只能用两个16位的地址，通过某个方法来合成一个20位的地址。</p>
<p>首先，我们把两个16位的地址分别称为段地址和偏移地址，计算方式是</p>
<p><em>物理地址 = 段地址 </em> 16 + 偏移地址*</p>
<p>比如 段地址为：1230h 偏移地址为 00c8，则物理地址等于</p>
<p>1230h * 16 + 00c8 = 123c8</p>
<h1 id="寄存器-CS-和-IP"><a href="#寄存器-CS-和-IP" class="headerlink" title="寄存器 CS 和 IP"></a>寄存器 CS 和 IP</h1><p>CS 和 IP 是 8086 最关键的两个寄存器，他们指示了当前CPU要读取指令的地址， CS 为代码段寄存器（存放了段地址）， IP 指令指正寄存器（存放了偏移地址）。</p>
<p>CPU 合成物理地址的原理是这样的：</p>
<p>首先 CS 和 IP 两个寄存器保存了两个16位物理地址，这两个地址将被送入地址加法器，通过上述的公式计算出物理地址，然后把物理地址送入输入输出控制电路，然后被送到地址总线，由地址总线把物理地址送入内存。具体的流程在书P26。</p>
<p>为了修改CPU要执行的指令，我们可以修改 CS 和 IP 寄存器</p>
<p><code>JMP 2AE3:3 这个指令表示修改段地址(CS)为2AE3，偏移地址为3h，CPU将会从2AE33处取指令</code></p>
<p>或者你不想修改段地址，只是修改偏移地址，你可以这样</p>
<p><code>JMP AX 表示把寄存器 AX 的值作为IP寄存器（偏移地址）的值</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于书&quot;&gt;&lt;a href=&quot;#关于书&quot; class=&quot;headerlink&quot; title=&quot;关于书&quot;&gt;&lt;/a&gt;关于书&lt;/h1&gt;&lt;p&gt;为了深入学习计算机底层，开始学习汇编。这是第一篇学习笔记，书是 王爽的《汇编语言》，这本书虽然是国人写的，但是不是一本一板一眼的书，
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>终于搭好了hexo</title>
    <link href="http://yoursite.com/2016/06/27/%E7%BB%88%E4%BA%8E%E6%90%AD%E5%A5%BD%E4%BA%86hexo/"/>
    <id>http://yoursite.com/2016/06/27/终于搭好了hexo/</id>
    <published>2016-06-27T09:13:12.000Z</published>
    <updated>2016-06-27T09:14:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>以后写博客就用它来写了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以后写博客就用它来写了。&lt;/p&gt;

    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
